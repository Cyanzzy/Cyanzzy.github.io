---
title: 数据结构-3-链表
date: 2023-02-23 11:57:46
tags: 
  - DataStructure
categories: 
  - Algorithm
swiper_index: 
---

> 引言：

**方法论**
* 对于笔试：一切为了时间复杂度，不用在乎空间复杂度
* 对于面试：时间复杂度放在首位，空间复杂度尽量最小

**重要技巧**
* 额外数据结构记录（哈希表等）
* 快慢指针

# 链表回文

> 方式1 利用快慢指针走到中点，将链表后一半放入栈

```java
// 方式1
public boolean isPalindrome(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    // 定义栈
    Stack<Node> stack = new Stack<Node>();
    
    // 定义右指针
    Node right = head.next;
    // 定义当前指针
    Node cur = head;

    while (cur.next != null || cur.next.next != null) {
        // 慢指针步长为1
        right = right.next;
        // 快指针步长为2
        cur = cur.next.next;
    }

    // 将链表的后半部分放入栈
    while (right != null) {
        stack.push(right);
        right = right.next;
    }
    
    // 判断
    while (!stack.isEmpty()) {
        if (head.val != stack.pop().val) {
            return false;
        }
        head = head.next;
    }
    
    return true;
}
```
> 方式2 利用快慢指针走到中点，将链表后一部分反转，双指针遍历

```java
// 方式2
public boolean isPalindrome(Node head) {
    if (head == null || head.next == null) {
        return true;
    }

    // 定义慢指针n1
    Node n1 = head;
    // 定义快指针n2
    Node n2 = head;

    // 当快指针走到链表末尾，慢指针便到达链表中点
    while (n2.next != null && n2.next.next != null) {
        // 慢指针步长为1
        n1 = n1.next;
        // 快指针步长为2
        n2 = n2.next.next;
    }

    // 快指针此时指向慢指针右半部分的第一个节点
    n2 = n1.next;
    // 中间节点的后继断链
    n1.next = null;
    // 定义辅助节点n3
    Node n3 = null;

    // 链表右半部分转置
    while (n2 != null) {
        // n3保存后继节点
        n3 = n2.next;
        // 开始转置
        n2.next = n1;
        n1 = n2;
        n2 = n3;
    }
    // n3指向转置后的链表的（从左至右）最后一个结点
    n3 = n1;
    // n2指向转置后的链表的（从左至右）第一个结点
    n2 = head;
    boolean res = true;

    // 回文判断
    while (n1 != null && n2 != null) {
        if (n1.val != n2.val) {
            res = false;
            break;
        }
        // 从左到中点
        n1 = n1.next;
        // 从右到中点
        n2 = n2.next;
    }

    n1 = n3.next;
    n3.next = null;

    // 复原链表
    while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
    return res;
}
```

# 链表划分

> 问题

给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。

> 进阶

* 在实现原问题功能的基础上增加如下的要求

* 调整后所有小于pivot的节点之间的相对顺序和调整前一样
* 调整后所有等于pivot的节点之间的相对顺序和调整前一样
* 调整后所有大于pivot的节点之间的相对顺序和调整前一样
* 时间复杂度请达到$O(N)$，额外空间复杂度请达到$O(1)$。

> 算法图解

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-38.png)

```java
public Node listPartition(Node head, int pivot) {
    // 定义sH、sT（小于pivot的部分）
    Node sH = null; Node sT = null;
    // 定义eH、eT（等于pivot的部分）
    Node eH = null; Node eT = null;
    // 定义bH、bT（大于pivot的部分）
    Node bH = null; Node bT = null;
    Node next = null;

    while (head != null) {
        // 断链
        next = head.next;
        head.next = null;

        // 若当前值小于枢轴
        if (head.val < pivot) {
            // 若左半部分没有任何节点时
            // s头指针sH和s尾指针sT都指向head
            if (sH == null) {
                sH = head;
                sT = head;
            } else { // 否则
                // s尾指针sT连接当前节点
                sT.next = head;
                // 更新s尾指针sT
                sT = head;
            }
        } else if (head.val == pivot) { // 若当前值等于枢轴
            // 若中间部分没有任何节点时
            // e头指针eH和e尾指针eT都指向head
            if (eH == null) {
                eH = head;
                eT = head;
            } else {
                // e尾指针eT连接当前节点
                eT.next = head;
                // 更新e尾指针eT
                eT = head;
            }

        } else { // 若当前值大于枢轴
            // 如果右半部分没有任何结点时
            // b头指针bH和b尾指针bT都指向head
            if (bH == null) {
                bH = head;
                bT = head;
            } else {
                // b尾指针bT连接当前节点
                bT.next = head;
                // 更新b尾指针bT
                bT = head;
            }
        }

        // 更新当前节点位置
        head = next;
    }

    // 如果存在左半段链表[见图解]
    if (sT != null) {
        // s尾指针sT后继指向e头指针eH
        sT.next = eH;
        eT = eT == null ? sT : eT;
    }

    // 如果左半段链表和中间段链表不是都没有[见图解]
    if (eT != null){
        eT.next = bH;
    }
    
    return sH != null ? sH : eH != null ? eH : bH;
}
```

