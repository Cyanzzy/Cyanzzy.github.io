---
title: 数据结构-3-链表
date: 2023-02-23 11:57:46
tags: 
  - DataStructure
categories: 
  - Algorithm
swiper_index: 
---

> 引言：

**方法论**
* 对于笔试：一切为了时间复杂度，不用在乎空间复杂度
* 对于面试：时间复杂度放在首位，空间复杂度尽量最小

**重要技巧**
* 额外数据结构记录（哈希表等）
* 快慢指针

# 链表回文

> 方式1 利用快慢指针走到中点，将链表后一半放入栈

```java
// 方式1
public boolean isPalindrome(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    // 定义栈
    Stack<Node> stack = new Stack<Node>();
    
    // 定义右指针
    Node right = head.next;
    // 定义当前指针
    Node cur = head;

    while (cur.next != null || cur.next.next != null) {
        // 慢指针步长为1
        right = right.next;
        // 快指针步长为2
        cur = cur.next.next;
    }

    // 将链表的后半部分放入栈
    while (right != null) {
        stack.push(right);
        right = right.next;
    }
    
    // 判断
    while (!stack.isEmpty()) {
        if (head.val != stack.pop().val) {
            return false;
        }
        head = head.next;
    }
    
    return true;
}
```
> 方式2 利用快慢指针走到中点，将链表后一部分反转，双指针遍历

```java
// 方式2
public boolean isPalindrome(Node head) {
    if (head == null || head.next == null) {
        return true;
    }

    // 定义慢指针n1
    Node n1 = head;
    // 定义快指针n2
    Node n2 = head;

    // 当快指针走到链表末尾，慢指针便到达链表中点
    while (n2.next != null && n2.next.next != null) {
        // 慢指针步长为1
        n1 = n1.next;
        // 快指针步长为2
        n2 = n2.next.next;
    }

    // 快指针此时指向慢指针右半部分的第一个节点
    n2 = n1.next;
    // 中间节点的后继断链
    n1.next = null;
    // 定义辅助节点n3
    Node n3 = null;

    // 链表右半部分转置
    while (n2 != null) {
        // n3保存后继节点
        n3 = n2.next;
        // 开始转置
        n2.next = n1;
        n1 = n2;
        n2 = n3;
    }
    // n3指向转置后的链表的（从左至右）最后一个结点
    n3 = n1;
    // n2指向转置后的链表的（从左至右）第一个结点
    n2 = head;
    boolean res = true;

    // 回文判断
    while (n1 != null && n2 != null) {
        if (n1.val != n2.val) {
            res = false;
            break;
        }
        // 从左到中点
        n1 = n1.next;
        // 从右到中点
        n2 = n2.next;
    }

    n1 = n3.next;
    n3.next = null;

    // 复原链表
    while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
    return res;
}
```


