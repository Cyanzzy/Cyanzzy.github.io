---
title: 算法导学-2-链表类型题目
date: 2023-02-23 11:58:00
tags: 
  - DataStructure
categories: 
  - Algorithm
swiper_index: 
---

# 移除链表元素

[LeetCode 203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

> 问题

给你一个链表的头节点`head`和一个整数`val`，请你删除链表中所有满足`Node.val == val`的节点，并返回**新的头节点**。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-37.jpg)

```Text
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```
## 迭代删除
> 算法思想

* 用`temp`表示当前节点。

* 如果`temp`的下一个节点不为空且下一个节点的节点值等于给定的`val`，则需要删除下一个节点。删除下一个节点可以通过以下做法实现： `temp.next = temp.next.next`

* 如果`temp`的下一个节点的节点值不等于给定的`val`，则保留下一个节点，将`temp`移动到下一个节点即可。

* 当`temp`的下一个节点为空时，链表遍历结束，此时所有节点值等于`val`的节点都被删除。 

* 由于链表的头节点`head`有可能需要被删除，因此创建哑节点`dummyHead`

* 令`dummyHead.next=head`，初始化`temp=dummyHead`，然后遍历链表进行删除操作。最终返回`dummyHead.next`即为删除操作后的头节点。

```java
public ListNode removeElements(ListNode head, int val) {
    // 定义虚节点
    ListNode dummyNode = new ListNode(0);
    
    dummyNode.next = head;
    ListNode temp = head;
    
    // 核心逻辑
    while (temp.next != null) {
        if (temp.next.val == val) {
            temp.next = temp.next.next;
        } else {
            temp = temp.next;
        }
    }
    return dummyNode.next;
}
```
> 复杂度分析

时间复杂度$O(n)$，n是链表长度，需要遍历链表一次；

## 递归删除

> 算法思想

* 首先对除了头节点`head`以外的节点进行删除操作，然后判断`head`的节点值是否等于给定的`val`。

* 如果`head`的节点值等于`val`，则`head`需要被删除，因此删除操作后的头节点为`head.next`；

* 如果`head`的节点值不等于`val`，则`head`保留，因此删除操作后的头节点还是`head`。

* 上述过程是一个递归的过程。

* 递归的终止条件是`head`为空，此时直接返回`head`。

* 当`head`不为空时，递归地进行删除操作，然后判断`head`的节点值是否等于`val`并决定是否要删除`head`。

```java
public ListNode removeElements(ListNode head, int val) {
    if (head == null) { // 递归终止条件
        return head;
    }
    // 递归删除下一个节点
    head.next = removeElements(head.next, val);

    /**
        * 判断head节点值是否等于给定的val。
        * 如果节点值等于val，则head需要被删除，因此删除操作后的头节点为head.next；
        * 如果head的节点值不等于val，则head保留，因此删除操作后的头节点还是head。
        * 上述过程是一个递归的过程。
        */
    return head.val == val ? head.next : head;
}
```
> 复杂度分析

时间复杂度$O(n)$，n是链表长度，递归过程需要遍历链表一次；空间复杂度$O(n)$，n是链表长度，取决于递归调用栈，最多不会超过n层

# 设计链表

[LeetCode 707.设计链表](https://leetcode.cn/problems/design-linked-list/)

> 问题

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

* get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。

* addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。

* addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。

* addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。

* deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

```java
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

## 单链表

### initialize
哨兵节点被用作伪头始终存在，这样结构中永远不为空，它将至少包含一个伪头。MyLinkedList 中所有节点均包含：值 + 链接到下一个元素的指针。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-39.jpg)
 
```java
public static class MyLinkedList {
    int size;
    ListNode head;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }
}
```
### addAtIndex

* 找到要插入位置节点的前驱节点。如果要在头部插入，则它的前驱节点就是伪头。

* 如果要在尾部插入节点，则前驱节点就是尾节点。

* 通过改变 `next` 来插入节点。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-40.jpg)
![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-41.jpg)

```java
toAdd.next = pred.next;
pred.next = toAdd;
```
### deleteAtIndex

* 找到要删除节点的前驱节点。

* 通过改变 `next` 来删除节点。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-42.jpg)

```java
// delete pred.next 
pred.next = pred.next.next;
```

### get

从伪头节点开始，向前走 `index+1` 步。 
![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-43.jpg)

```java
// index steps needed 
// to move from sentinel node to wanted index
for(int i = 0; i < index + 1; ++i) curr = curr.next;
return curr.val;
```
### summery
```java
public static class MyLinkedList {
    int size;
    ListNode head;

    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    // Add a node of value val before the index-th node in the linked list.
    // If index equals to the length of linked list, the node will be appended to the end of linked list.
    // If index is greater than the length, the node will not be inserted.
    public void addAtIndex(int index, int val) {

        //If index is greater than the length,
        // the node will not be inserted.
        if (index > size) {
            return;
        }

        // [so weird] If index is negative,
        // the node will be inserted at the head of the list.
        if (index < 0) {
            index = 0;
        }
        ++size;

        //find predecessor of the node to be added
        ListNode pre = head;
        for (int i = 0; i < index; i++) {
            pre = pre.next;
        }

        // node to be added
        ListNode toAdd = new ListNode(val);

        // insertion itself
        toAdd.next = pre.next;
        pre.next = toAdd;
    }


    // Add a node of value val before the first element of the linked list.
    // After the insertion, the new node will be the first node of the linked list.
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    // Append a node of value val to the last element of the linked list.
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    //  Delete the index-th node in the linked list, if the index is valid.
    public void deleteAtIndex(int index) {

        // if the index is invalid, do nothing
        if (index < 0 || index >= size) return;

        size--;

        // find predecessor of the node to be deleted
        ListNode pre = head;
        for(int i = 0; i < index; ++i) {
            pre = pre.next;
        }
        
        // delete pre.next
        pre.next = pre.next.next;
    }

    // Get the value of the index-th node in the linked list. If the index is invalid, return -1.
    public int get(int index) {
        
        // if index is invalid
        if (index < 0 || index >= size) {
            return -1;
        }

        ListNode cur = head;
        
        // index steps needed
        // to move from sentinel node to wanted index
        for (int i = 0; i < index + 1; i++) {
            cur = cur.next;
        }
        
        return cur.val;
    }
}
```
## 双链表

### initialize

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-44.jpg)

```java
public static class MyLinkedList {

    int size;

    //虚拟节点
    DListNode head, tail;

    public MyLinkedList2() {
        size = 0;
        head = new DListNode(0);
        tail = new DListNode(0);
        head.next = tail;
        tail.pre = head;
    }
}
```
### addAtIndex

* 找到要插入节点的前驱节点和后继节点。

* 如果要在头部插入节点，则它的前驱结点是伪头。

* 如果要在尾部插入节点，则它的后继节点是伪尾。

* 通过改变前驱结点和后继节点的链接关系添加元素。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-45.jpg)

```java
toAdd.prev = pred
toAdd.next = succ
pred.next = toAdd
succ.prev = toAdd
```
### deleteAtIndex

* 找到要删除节点的前驱结点和后继节点。
* 通过改变前驱结点和后继节点的链接关系删除元素。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-46.jpg)

```java
pred.next = succ
succ.prev = pred
```
### get

* 通过比较 `index` 和 `size - index` 的大小判断从头开始较快还是从尾巴开始较快。
* 从较快的方向开始。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-47.jpg)

```java
// choose the fastest way: to move from the head
// or to move from the tail
ListNode curr = head;
if (index + 1 < size - index)
  for(int i = 0; i < index + 1; ++i) curr = curr.next;
else {
  curr = tail;
  for(int i = 0; i < size - index; ++i) curr = curr.prev;
}
```
### summery
```java
public class MyLinkedList {
    
    int size;
    
    // dummyNode
    DListNode head, tail;

    public MyLinkedList() {
        size = 0;
        head = new DListNode(0);
        tail = new DListNode(0);
        head.next = tail;
        tail.pre = head;
    }

    // Get the value of the index-th node in the linked list. If the index is invalid, return -1.
    public int get(int index) {
        
        // if index is invalid
        if (index < 0 || index >= size) return -1;

        // choose the fastest way: to move from the head
        // or to move from the tail
        DListNode cur = head;
        if (index + 1 < size - index)
            for(int i = 0; i < index + 1; ++i) cur = cur.next;
        else {
            cur = tail;
            for(int i = 0; i < size - index; ++i) cur = cur.pre;
        }

        return cur.val;
    }

    // Add a node of value val before the first element of the linked list.
    // After the insertion, the new node will be the first node of the linked list.
    public void addAtHead(int val) {
        DListNode pre = head, succ = head.next;

        ++size;
        DListNode toAdd = new DListNode(val);
        toAdd.pre = pre;
        toAdd.next = succ;
        pre.next = toAdd;
        succ.pre = toAdd;
    }

    // Append a node of value val to the last element of the linked list.
    public void addAtTail(int val) {
        DListNode succ = tail, pre = tail.pre;

        ++size;
        DListNode toAdd = new DListNode(val);
        toAdd.pre = pre;
        toAdd.next = succ;
        pre.next = toAdd;
        succ.pre = toAdd;
    }
    
    // Add a node of value val before the index-th node in the linked list.
    // If index equals to the length of linked list, the node will be appended to the end of linked list.
    // If index is greater than the length, the node will not be inserted.
    public void addAtIndex(int index, int val) {
        
        // If index is greater than the length,
        // the node will not be inserted.
        if (index > size) return;

        // [so weird] If index is negative,
        // the node will be inserted at the head of the list.
        if (index < 0) index = 0;

        // find predecessor and successor of the node to be added
        DListNode pre, succ;
        if (index < size - index) {
            pre = head;
            for(int i = 0; i < index; ++i) pre = pre.next;
            succ = pre.next;
        }
        else {
            succ = tail;
            for (int i = 0; i < size - index; ++i) succ = succ.pre;
            pre = succ.pre;
        }

        // insertion itself
        ++size;
        DListNode toAdd = new DListNode(val);
        toAdd.pre = pre;
        toAdd.next = succ;
        pre.next = toAdd;
        succ.pre = toAdd;
    }

    // Delete the index-th node in the linked list,
    // if the index is valid.
    public void deleteAtIndex(int index) {
        
        // if the index is invalid, do nothing
        if (index < 0 || index >= size) return;

        // find predecessor and successor of the node to be deleted
        DListNode pre, succ;
        if (index < size - index) {
            pre = head;
            for(int i = 0; i < index; ++i) pre = pre.next;
            succ = pre.next.next;
        }
        else {
            succ = tail;
            for (int i = 0; i < size - index - 1; ++i) succ = succ.pre;
            pre = succ.pre.pre;
        }

        // delete pred.next
        --size;
        pre.next = succ;
        succ.pre = pre;
    }

}
public class DListNode {
    int val;
    DListNode next;
    DListNode pre;

    public DListNode(int val) {
        this.val = val;
    }
}
```