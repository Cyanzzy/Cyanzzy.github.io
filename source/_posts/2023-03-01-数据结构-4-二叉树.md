---
title: 数据结构-4-二叉树
date: 2023-03-01 14:30:40
tags: 
  - DataStructure
categories: 
  - Algorithm
swiper_index: 
---
# 二叉树的遍历
## 先序遍历
### 递归版本

```java
public void preorder(Node head) {
    if (head == null) {
        return;
    }
    Visit(head);
    preorder(head.left);
    preorder(head.right);
}
```
### 非递归版本

```java
public void preOrder(Node head) {
    
    if (head != null) {
        // 定义辅助栈
        Stack<Node> stack = new Stack<>();
        // 根节点入栈
        stack.add(head);
        
        while (!stack.isEmpty()) {
            // 弹出栈顶一个节点
            head = stack.pop();
            Visit(head);
            // 先入栈该节点的右孩子
            if (head.right != null) {
                stack.push(head.right);
            }
            // 再入栈该节点的左孩子
            if (head.left != null) {
                stack.push(head.left);
            }
        }
    }
} 
```

## 中序遍历
### 递归版本

```java
public void inorder(Node head) {
    if (head == null) {
        return;
    }
    inorder(head.left);
    Visit(head);
    inorder(head.right);
}
```
### 非递归版本
```java
public List<Node> inorder(Node head) {
    List<Node> ans = new ArrayList<>();
    Stack<Node> stack = new Stack<>();
    
    if (head == null) {
        return ans;
    }
    
    while (!stack.isEmpty() || head != null) {
        // 一直往左分支走
        while (head != null) {
            stack.push(head);
            head = head.left;
        }
        
        if (!stack.isEmpty()) {
            head = stack.pop();
            ans.add(head); // Visit(head)
            // 转向右分支
            head = head.right;
        }
        
    }
    return ans;
}
```
## 后序遍历
### 递归版本

```java
public void postorder(Node head) {
    if (head == null) {
        return;
    }
    postorder(head.left);
    postorder(head.right);
    //Visit(head);
}
```
### 非递归版本

```java
// 逆先序
public void postorder(Node head) {
    
    if (head != null) {
        // 输入栈
        Stack<Node> in = new Stack<>();
        // 输出栈
        Stack<Node> out = new Stack<>();
        
        // 将根节点放入输入栈
        in.push(head);
        
        while (!in.isEmpty()) {
            
            // 从输入栈取出栈顶元素放入输出栈中
            head = in.pop();
            out.push(head);
            
            if (head.left != null) {
                in.push(head.left);
            }
            
            if (head.right != null) {
                out.push(head.right);
            }
        }
        
        // 输出
        while (!out.isEmpty()) {
            out.pop();
        }
    }
}
```

# 二叉树宽度

```java
public int getWidth(Node head) {

    int maxsize = 100;
    // 定义哨兵
    Node sentinel;
    // 定义队列
    Node[] que = new Node[maxsize]; // MaxSize根据实际题目而定
    // 定义指针
    int front = 0, rear = 0;
    // 记录当前最大宽度
    int max = 0;
    // 定义当前层次节点数
    int count = 0;
    // 记录当前层次最后一个节点
    int last = 1;

    // 根节点入队
    rear = (rear + 1) % maxsize;
    que[rear] = head;

    while (front != rear) {
        // 出队一个节点
        front = (front + 1) % maxsize;
        sentinel = que[front];

        // 记录当前节点
        count++;

        // 哨兵节点的左孩子入队
        if (sentinel.left != null) {
            rear = (rear +1) % maxsize;
            que[rear] = sentinel.left;
        }

        // 哨兵节点的右孩子入队
        if (sentinel.right != null) {
            rear = (rear +1) % maxsize;
            que[rear] = sentinel.right;
        }

        // 更新层次
        if (front == last) {
            // last指向下一层层次最后一个节点
            last = rear;
            // 更新最大节点数
            max = count > max ? count : max;
            // 重置节点数
            count = 0;
        }
    }
    return max;
}
```
# 二叉搜索树

## 判断方式1 遍历中序序列

> 算法思想

二叉搜索树中序遍历序列呈递增特性。

```java
public boolean isBST(Node head) {
    // 空树符合要求
    if (head == null) {
        return false;
    }

    List<Node> inList = new LinkedList<>();

    process(head, inList);

    int pre = Integer.MIN_VALUE;

    // 如果中序遍历不是递增的，不是二叉搜索树
    for (Node node: inList) {
        if (pre >= node.val) {
            return false;
        }
        pre = node.val;
    }
    return true;
}

public void process(Node node, List<Node> inList) {
    if (node == null) {
        return;
    }
    process(node.left, inList);
    inList.add(node);
    process(node.right, inList);
}
```
## 判断方式2 常规递归检查
> 算法思想

判断是否为BST，主要是看BST性质：对于其下的任意一颗子树，其左孩子节点的值小于其根节点的值，其根节点的值小于其右孩子的值，因此用递归解决

```java
int prev = Integer.MIN_VALUE;

public boolean isBST(Node head) {
    // 空树是一个BST
    if (head == null) {
        return true;
    }
    // 首先检查左子树，需要返回一个结果
    boolean isLeftBST = isBST(head.left);

    // 如果左子树不符合要求，则返回false
    if (!isLeftBST) {
        return false;
    }
    // 检查当前节点与它左孩子大小
    if (head.val <= prev) {
        // 不满足条件
        return false;

    } else {
        // 更新prev，准备检查右子树
        prev = head.val;
    }
    // 检查其右子树
    return isBST(head.right);
}
```
## 判断方式3 树型DP套路
> 树型DP使用场景

如果题目求解目标S规则，其求解流程定成以每一个节点为头结点的子树在S下的每个答案，并且最终答案一定在其中

> 算法思想

* 判断BST，以X为根节点的BST满足：左子树为BST，右子树为BST，对应左子树的 $max<X$，右子树的 $min>X$
* 因此左子树需要的信息 （1.左子树是否为BST 2.左子树的Max）
* 因此右子树需要的信息  (1.右子树是否为BST 2.右子树的Min)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-59.png)

`Step1` 以某个节点X为头结点的子树中，分析答案的可能性，并且可能性是以X的左子树、X的右子树和X整棵树的角度考虑的
1. X左子树是否为BST
2. X右子树是否为BST
3. 以X为根节点的树是否为BST

`Step2` 根据可能性，列出需要的信息
1. 左子树是否为BST
2. 左子树的最大值
3. 右子树是否为BST
4. 右子树的最小值

`Step3` 合并第二步信息，对左子树和右子树提出同样要求，写出信息结构
```java
public class ReturnData {
    
    // 该子树是否为BST
    public boolean isBST;
    // 该子树中最小值
    public int min;
    // 该子树中最大值
    public int max;

    public ReturnData(boolean isBST, int min, int max) {
        this.isBST = isBST;
        this.min = min;
        this.max = max;
    }

}
```
`Step4` 设计递归函数，递归函数处理以X为头节点的情况下的答案，包括设计递归的basecase，默认直接得到左子树和右子树的所有信息，以及把可能性做出整合

```java
public ReturnData process(Node head) {

    // 如果头节点为空，返回null
    if (head == null) {
        return null;
    }

    // 递归检查左子树
    ReturnData leftData = process(head.left);
    // 递归检查右子树
    ReturnData rightData = process(head.right);

    /*核心代码*/

    // 记录右子树的最小值
    int min = head.val;
    // 记录左子树的最大值
    int max = head.val;

    // 求出左孩子最小值与最大值
    if (leftData != null) {
        min = Math.min(min, leftData.min);
        max = Math.max(max, leftData.max);
    }
    // 求出右孩子最小值与最大值
    if (rightData != null) {
        min = Math.min(min, rightData.min);
        max = Math.max(max, rightData.max);
    }

    boolean isBST = true;

    // 当左孩子不是BST或左孩子中的最大值>=head时，返回false
    if (leftData != null && (!leftData.isBST || leftData.max >= head.val)) {
        isBST = false;
    }
    // 当右孩子不是BST或右孩子中的最小值<=head时，返回false
    if (rightData != null && (!rightData.isBST || head.val >= rightData.min)) {
        isBST = false;
    }

    // 返回整合后的信息结构
    return new ReturnData(isBST, max, min);
}
```

```java
public boolean isBST(Node head) {
    return process(head).isBST;
}
```

# 完全二叉树

> 算法思想

* 层次遍历二叉树

* 如果当前节点有右孩子节点，但没有左孩子节点，直接返回 `false`

* 如果当前节点并不是全有左右孩子，那么之后的节点必须为叶子节点，否则返回`false`

* 遍历过程不返回`false`，遍历结束后返回`true`

```java
public boolean isCBT(Node head) {
    // 空树符合要求
    if (head == null) {
        return true;
    }

    LinkedList<Node> queue = new LinkedList<>();

    // 定义叶子判断标记
    boolean leaf = false;

    // 定义双指针
    Node lchild = null;
    Node rchild = null;

    // 头节点入队
    queue.add(head);

    while (!queue.isEmpty()) {
        // 弹出队首节点
        head = queue.poll();
        lchild = head.left;
        rchild = head.right;

        // 1. 开启叶子判断
        // 2. 如果有右孩子但无左孩子，则返回false
        if (leaf && (lchild != null || rchild!= null) || (lchild == null && rchild != null)) {
            return false;
        }
        
        // 左孩子入队
        if (lchild != null) {
            queue.add(lchild);
        }
        
        // 右孩子入队
        if (rchild != null) {
            queue.add(rchild);
        }
        
        // 第一次遇到不是拥有两个孩子的节点，则开启叶子判断
        if (lchild == null || rchild == null) {
            leaf = true;
        }
    }
    return true;
}
````
# 平衡二叉树

`Step1` 以 `X` 为头节点的子树中，分析答案的可能性。以`X`的左子树、`X`的右子树和`X`整棵树角度分析可能性

* `X`的左子树是否平衡

* `X`的右子树是否平衡

* `X`为头结点的左右子树高度差

* 上述满足后，则平衡

`Step2` 根据可能性列出需要的信息，本题是要知道左子树是否平衡，右子树是否平衡，以及高度信息

`Step3` 整合信息

```java
// 信息结构
public class ReturnData {

    // 是否平衡
    public boolean isBalanced;

    // 高度
    public int height;

    public ReturnData(boolean isBalanced, int height) {
        
        this.isBalanced = isBalanced;
        this.height = height
    }

}
```

`Step4` 设计递归函数，处理以X为头节点的情况的答案，包括 base case，左右子树信息，以及可能性整合，返回信息结构

```java
// 递归函数
public ReturnData process(Node x) {

    // 空树满足条件
    if (x == null) {
        return new ReturnData(true, 0);
    }

    // 递归检查左子树
    ReturnData leftData = process(x.left);

    // 递归检查右子树
    ReturnData rightData = process(x.right);

    // 树的高度
    int height = Math.max(leftData.height, rightData.height) + 1;

    // 平衡性
    boolean isBalanced = leftData.isBalanced && rightData.isBalanced && Math.abs(leftData.height - rightData.height) < 2;
    
    // 返回整合的信息
    return new ReturnData(isBalanced, height);
}
```

调用函数

```java
// 调用
public boolean isBalanced(Node head) {
    return process(head).isBalanced;
}
```
