---
title: 算法导学-3-哈希表类型题目
date: 2023-03-08 15:41:34
tags: 
  - DataStructure
categories: 
  - Algorithm
swiper_index: 
---

# 有效的字母异位词
[LeetCode 242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

注意：若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

```text
输入: s = "anagram", t = "nagaram"
输出: true
```

## 排序法
* *t* 是 *s* 的异位词等价于「两个字符串排序后相等」。
* 因此我们可以对字符串*s* 和*t* 分别排序，看排序后的字符串是否相等即可判断。
* 此外，如果*s* 和*t* 的长度不同，*t* 必然不是*s* 的异位词。

```java
// 排序法
public boolean isAnagram(String s, String t) {
    // 长度不相等，之u姐舍弃
    if (s.length() != t.length()) {
        return false;
    }
    // 排序比较
    char[] chars1 = s.toCharArray();
    char[] chars2 = t.toCharArray();

    Arrays.sort(chars1);
    Arrays.sort(chars2);

    return Arrays.equals(chars1, chars2);
}
```
> 复杂度分析

O(nlogn)。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为O(n)，因此总体时间复杂度为$O(nlogn+n)=O(nlogn)$。排序需要O(logn)的空间复杂度。


## 哈希法

* 维护一个长度为26 的频次数组*table*，先遍历记录字符串*s* 中字符出现的频次，然后遍历字符串*t*，减去*table* 中对应的频次，
* 如果出现 $table[i]<0$，则说明 *t* 包含一个不在*s* 中的额外字符，返回 *false* 即可。

```java
public boolean isAnagram(String s, String t) {
    // 长度不相等，之u姐舍弃
    if (s.length() != t.length()) {
        return false;
    }

    int[] table = new int[26];
    // 统计词频
    for (int i = 0; i < s.length(); i++) {
        table[s.charAt(i) - 'a']++;
    }
    // 遇到一样的字符，对应减去即可
    for (int i = 0; i < t.length(); i++) {
        table[t.charAt(i) - 'a']--;
        if (table[t.charAt(i) - 'a'] < 0) {
            return false;
        }
    }
    return true;
}
```

> 遇到Unicode字符

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    Map<Character, Integer> table = new HashMap<Character, Integer>();

    for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        table.put(ch, table.getOrDefault(ch, 0) + 1);
    }
    
    for (int i = 0; i < t.length(); i++) {
        char ch = t.charAt(i);
        table.put(ch, table.getOrDefault(ch, 0) - 1);
        if (table.get(ch) < 0) {
            return false;
        }
    }
    return true;
}
```

# 两个数组的交集

[LeetCode 349.两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

> 问题

给定两个数组 `nums1` 和 `nums2` ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

```text
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

## 双指针 + 排序
> 算法思想

1. 首先对两个数组进行排序，呈非递减状态
2. 用pre表示上次加入答案数组的元素
3. 使用双指针分别指向两个数组，每次两个指针比较指向的位置的值
 * 如果两值不相等，则指向较小的数字的指针右移一位
 * 如果两值相等，且该数组不等于pre，将答案添加，并且双指针右移
 * 当至少一个指针超出数组反问，则遍历结束

```java
// 双指针 + 排序
public int[] intersection(int[] nums1, int[] nums2) {
    // 排序操作
    Arrays.sort(nums1);
    Arrays.sort(nums2);

    int len1 = nums1.length;
    int len2 = nums2.length;

    int[] ans = new int[len1  + len2];

    int cur = 0, i = 0, j = 0;

    while (i < len1 && j < len2) {
        if (nums1[i] == nums2[j]) {
            if (cur == 0 || nums1[i] != ans[cur - 1]) {
                ans[cur++] = nums1[i];
            }
            i++;
            j++;
        } else  if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    return Arrays.copyOfRange(ans, 0, cur);
}
```  
> 复杂度分析

O(mlogm+nlogn)，其中m和n为数组的长度。对两个数组排序的时间复杂度分别是O(mlogm)和O(nlogn)，双指针寻找交集元素的时间复杂度是O(m+n)，因此总时间复杂度是O(mlogm+nlogn)。

## 哈希
> 算法思想

1. 使用两个集合存储数组元素
2. 遍历较小集合 
3. 判断该集合元素是否在另一个集合中
4. 如果在直接加入

```java
// 哈希
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> set1 = new HashSet<>();
    Set<Integer> set2 = new HashSet<>();

    for (int num : nums1) {
        set1.add(num);
    }

    for (int num : nums2) {
        set2.add(num);
    }
    return getInterSection(set1, set2);
}

public int[] getInterSection(Set<Integer> smallSet, Set<Integer> bigSet) {
    // 保持调用形式
    if (smallSet.size() > bigSet.size()) {
        return getInterSection(bigSet, smallSet);
    }

    Set<Integer> ans = new HashSet<>();

    // 遍历小集合
    for (Integer num : smallSet) {
        if (bigSet.contains(num)) {
            ans.add(num);
        }
    }

    // Set-->int[]
    int[] intersection = new int[ans.size()];
    int index = 0;

    for (int el : ans) {
        intersection[index++] = el;
    }
    
    return intersection;
}
```

> 复杂度分析

O(m+n)，其中m和n 为数组的长度。存储两个数组需要O(m+n)的时间，遍历较小的集合需要O(min(m,n))的时间

# 快乐数

[LeetCode 202.快乐数]()

> 问题

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

  *   对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
  *   然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
   *  如果这个过程 结果为 1，那么这个数就是快乐数。
如果 `n` 是 快乐数 就返回 `true` ；不是，则返回 `false` 。

```text
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

输入：n = 2
输出：false
```

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-65.png)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-66.png)

## 哈希表
>  猜测三种情况

* 最终得到1
* 最终进入循环
* 值越来越大，趋于无穷
> 表格表示每位数的最大数字的下一位

| Digits |    Largest    | Next |
| ------ | :-----------: | ---: |
| 1      |       9       |   81 |
| 2      |      99       |  162 |
| 3      |      999      |  243 |
| 4      |     9999      |  324 |
| 13     | 9999999999999 | 1053 |

* 3位的数字不可能超过243，要么在243以下的循环内，要么跌到1

* 4位以及4位以上的每走一步丢失一位，直到降到3位为止

* 最坏的情况下，算法可能会在243以下的所有数字上循环，然后回到它已经到过的一个循环或者回到1。但它不会无限期地进行下去，所以我们排除第三种选择。  

> 算法实现

1.给一个数字 *n*，它的下一个数字是什么？**数位分离，求平方和。**
2.按照一系列的数字来判断我们是否进入了一个循环。
使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。

* 如果它不在哈希集合中，我们应该添加它。
* 如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。

```java
public int getNext(int n) {
    int totalSum = 0;

    // 对于 19
    // 低 --> 高
    while (n > 0) {
        // digit = 19 % 10 = 9
        int digit = n % 10;

        // n = 19 / 10 = 1
        n = n / 10;
        totalSum += digit * digit;
    }
    return totalSum;
}

public boolean isHappy(int n) {
    Set<Integer> seen = new HashSet<>();
    
    //  一旦出现重复的就返回false
    while (n != 1 && !seen.contains(n)) {
        seen.add(n);
        n = getNext(n);
    }
    return n == 1;
}
```

## 链表有环 

反复调用getNext(n)，得到隐式链表，**转换成链表是否有环问题**

* 如果*n*是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。

* 如果*n*不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。

```java
public boolean isHappy(int n) {
    int slow = n;
    int fast = getNext(n);

    while (fast != 1 && slow != fast) {
        // slow = slow.next
        slow = getNext(slow);
        
        // fast = fast.next.next
        fast = getNext(getNext(fast));
    }
    return fast == 1;
}
```