---
title: JavaBasic-1-基础内容
date: 2023-03-16 17:56:07
tags: 
  - JavaBasic
categories: 
  - Language
swiper_index: 
---
# 基础语法

> 基础语法

| 术语     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 对象     | 对象是类的一个实例，有状态和行为                             |
| 类       | 类是一个模板，它描述一类对象的行为和状态                     |
| 方法     | 方法就是行为，一个类可以有很多方法                           |
| 实例变量 | 每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定 |

> 注意事项

| 注意事项       | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **大小写敏感** | Java 是大小写敏感的                                          |
| **类名**       | 对于所有的类来说，类名的首字母应该大写。                     |
| **方法名**     | 所有的方法名都应该以小写字母开头                             |
| **源文件名**   | 源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java** |
| **主方法入口** | 所有的 Java 程序由 **public static void main(String[] args)** 方法开始执行。 |

> 标识符

 Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 

- 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始
- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
- 关键字不能用作标识符
- 标识符是大小写敏感的

> 修饰符

Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：

- 访问控制修饰符 : default, public , protected, private
- 非访问控制修饰符 : final, abstract, static, synchronized

> 类和对象的关系

* 类是现实生活中一类具有**共同属性**和**行为**的事物的抽象
* 类的组成：属性和行为(方法)

* 对象是由类实例化而来
* 一个类可以有多个对象
* 创建对象的方法：`类名 对象名 = new 类名();`

## 数据类型

Java 的两大数据类型:

- 内置数据类型
- 引用数据类型

> 内置数据类型 byte; short; int; long; float; double; boolean; char

| byte                                                         |
| :----------------------------------------------------------- |
| byte 数据类型是8位、有符号的，以二进制补码表示的整数；       |
| 最小值是 **-128（-2^7）**；                                  |
| 最大值是 **127（2^7-1）**；                                  |
| 默认值是 **0**；                                             |
| byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一 |

| short                                                  |
| ------------------------------------------------------ |
| short 数据类型是 16 位、有符号的以二进制补码表示的整数 |
| 最小值是 **-32768（-2^15）**；                         |
| 最大值是 **32767（2^15 - 1）**；                       |
| 默认值是 **0**；                                       |
| 一个short变量是int型变量所占空间的二分之一；           |

| int                                                  |
| ---------------------------------------------------- |
| int 数据类型是32位、有符号的以二进制补码表示的整数； |
| 最小值是 **-2,147,483,648（-2^31）**；               |
| 最大值是 **2,147,483,647（2^31 - 1）**；             |
| 默认值是 **0** ；                                    |
| 一般地整型变量默认为 int 类型；                      |

| **long**                                                |
| ------------------------------------------------------- |
| long 数据类型是 64 位、有符号的以二进制补码表示的整数； |
| 最小值是 **-9,223,372,036,854,775,808（-2^63）**；      |
| 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；     |
| 默认值是 **0L**；                                       |
| 主要使用在需要比较大整数的系统上                        |

| float                                                    |
| -------------------------------------------------------- |
| float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； |
| 默认值是 **0.0f**；                                      |
| 浮点数不能用来表示精确的值                               |
| float 在储存大型浮点数组的时候可节省内存空间             |

| **double**                                                   |
| ------------------------------------------------------------ |
| double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数； |
| 浮点数的默认类型为 double 类型；                             |
| 默认值是 **0.0d**；                                          |
| double类型同样不能表示精确的值，如货币；                     |

| boolean                         |
| ------------------------------- |
| boolean数据类型表示一位的信息； |
| 只有两个取值：true 和 false；   |
| 默认值是 **false**              |

| char                                       |
| ------------------------------------------ |
| char 类型是一个单一的 16 位 Unicode 字符； |
| 最小值是 **\u0000**（十进制等效值为 0）；  |
| 最大值是 **\uffff**（即为 65535）；        |
| char 数据类型可以储存任何字符；            |

> 引用类型

* 引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 

* 对象、数组都是引用数据类型。

* 所有引用类型的默认值都是null。

* 一个引用变量可以用来引用任何与之兼容的类型。

## 流程控制

> 顺序结构

 顺序结构的程序语句只能被执行一次。 

> 循环结构


Java中有三种主要的循环结构：

- **while** 循环

  ```java
  while( 布尔表达式 ) {
    // 循环内容
  }
  ```

- **do…while** 循环

  ```java
  do {
         // 代码语句
  }while(布尔表达式);
  ```

   do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 

- **for** 循环

  ```java
  for(初始化; 布尔表达式; 更新) {
      // 代码语句
  }
  ```

> foreach循环

```java
for(声明语句 : 表达式)
{
   // 代码句子
}
```

**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。

**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。

> break 

* break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。

* break 跳出最里层的循环，并且继续执行该循环下面的语句。

> continue

* continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。

* 在 for 循环中，continue 语句使程序立即跳转到更新语句。

* 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。

> switch case

```java
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
```

## 成员变量和局部变量

* 成员变量：类中方法外的变量

* 局部变量：方法中的变量

* 区别

  |      区别      |                成员变量                |                    局部变量                    |
  | :------------: | :------------------------------------: | :--------------------------------------------: |
  |  类中位置不同  |               类中方法外               |          方法内或或者方法声明上(形参)          |
  | 内存中位置不同 |                 堆内存                 |                     栈内存                     |
  |    生命周期    | 随对象的存在而存在，随对象的消失而消失 | 随着方法的调用而存在，随着方法的调用完毕而消失 |
  |  初始化值不同  |            有默认的初始化值            |  没有默认的初始化值，必须先定义，赋值才能使用  |

# 数组

Java 语言中提供的数组是用来存储固定大小的同类型元素。 

```java
dataType[] arrayRefVar;   // 首选的方法
```

> Arrays类

| 方法         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| binarySearch | 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 |
| equals       | 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的 |
| fill         | 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。   |
| sort         | 对指定对象数组根据其元素的自然顺序进行升序排列。             |


# 面向对象

## 方法

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

## 重载

 一个类的两个方法拥有相同的名字，但是有不同的参数列表, 重载的方法必须拥有不同的参数列表 

> 注意事项和细节 

1. ⽅法名：必须相同 
2. 形参列表：必须不同(参数类型、个数、顺序) 
3. 返回类型：⽆要求 

## 封装

封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作⽅法封装在⼀起数据被保护在内部，程序的其它部分只有通过被授权的操作（⽅法），才能对数据进⾏操作 

> 封装的优点

- 良好的封装能够减少耦合。
- 类内部的结构可以自由修改。
- 可以对成员变量进行更精确的控制。
- 隐藏信息，实现细节。

> 封装步骤

1. 将属性进⾏私有化private【不能直接修改属性】

2. 提供⼀个公共的(public)set⽅法，⽤于对属性判断井赋值 

   ```java
   public void setXxx(类型 参数名){ 
       加⼊数据验证的业务逻辑; 
       属性 = 参数名;
   } 
   ```

3. 提供个公共的(public)get⽅法，⽤于获取属性的值 

   ```java
   public 数据类型 getXxx{ return XX;} 
   ```

## 继承

 注意的是 Java 不支持多继承，但支持多重继承。 

```java
class 父类 {
}
 
class 子类 extends 父类 {
}
```

> 特性

- 子类拥有父类**非 private** 的属性、方法。
- 子类可以拥有自己的属性和方法，即**子类可以对父类进行扩展。**
- 子类可以用自己的方式实现父类的方法。
- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
- 提高了类之间的耦合性（**继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差**）。

> super 

* 可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

> this

* this关键字：指向自己的引用。
* 在类的方法内如果局部变量和成员变量出现同名的情况下，Java会使用“就近原则”，将同名的成员变量当作局部变量
* 为了在方法内使用到成员变量，可以使用**this**关键字
* this关键字的作用：可以调用本类的成员(变量、方法)，解决局部变量和成员变量重名的问题
* this代表所在类的对象引用，方法被哪个对象调用，this就代表哪个对象

> 注意事项

* ⼦类继承了所有的属性和⽅法，⾮私有的属性和⽅法可以在⼦类直接访问，但是私有属性和⽅法不能在⼦类直接访问，要通过⽗类提供公共的⽅法去访问 
* ⼦类**必须**调⽤⽗类的构造器，完成⽗类的初始化
* 当创建⼦类对象时，不管使⽤⼦类的哪个构造器，默认情况下总会去调⽤⽗类的⽆参构造器，如果⽗类 没有提供⽆参构造器，则必须在⼦类的构造器中⽤ super 去指定使⽤⽗类的哪个构造器完成对⽗类的初始化⼯作，否则，编译不会通过
* 指定去调⽤⽗类的某个构造器，则显式的调⽤⼀下：super(参数列表)    
* super在使⽤时，必须放在构造器第⼀⾏(super只能在构造器中使⽤)  
* super()和this()都只能放在构造器第⼀⾏，因此这两个⽅法不能共存在⼀个构造器
* ⽗类构造器的调⽤不限于直接⽗类！将⼀直往上追潮直到Object类  
* 不能滥⽤继承，⼦类和⽗类之间必须满⾜ is-a 的逻辑关系 
* ⼦类最多只能继承⼀个⽗类(指直接继承)，即java中是单继承机制 

## 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作

> 多态存在的必要条件

- 继承
- 重写
- 父类引用指向子类对象：**Parent p = new Child();**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/01-java-basic-20230311-01.jpg)

```java
class Shape {
    void draw() {}
}
 
class Circle extends Shape {
    void draw() {
        System.out.println("Circle.draw()");
    }
}
 
class Square extends Shape {
    void draw() {
        System.out.println("Square.draw()");
    }
}
 
class Triangle extends Shape {
    void draw() {
        System.out.println("Triangle.draw()");
    }
}
```

# 抽象类

> 概述

抽象方法：

将共性的行为（方法）抽取到父类后，发现**该方法的实现逻辑无法在父类中给出具体的含义**，该方法就可以定义为抽象方法

抽象类：

如果一个类中存在抽象方法，那么该类必须声明为抽象类

> 注意事项

* 抽象类不允许实例化
* 抽象类中**存在**构造方法
* 抽象类的子类**必须**重写所有的抽象方法，或者子类也是一个抽象类
* 抽象类中可以没有抽象方法，但是存在抽象方法一定是抽象类

# 内部类

内部类指在一个类中定义一个类

> 成员内部类

* 位置：在类的成员位置
* 内部类可以直接访问外部类中的成员，包括私有
* 外部类要访问内部类的成员，必须创建对象
* 在外界创建内部类对象的语法是`外部类名.内部类名 引用名 = new 外部类名().new 内部类名();`
* private修饰的成员内部类（私有成员内部类）
  1. 不能在外界创建该内部类，因为private修饰
  2. 只能在自己所在的外部类中创建对象来访问
* static修饰的成员内部类（静态成员内部类）
  1. 可以在外界创建
  2. 创建语法与普通的成员内部类不同`外部类名.内部类名 引用名 = new 外部类名.内部类名();`
  3. 静态成员内部类中的静态方法使用语法是`外部类名.内部类名.方法名();`

> 局部内部类

* 局部内部类是在方法中定义的内部类，所以外界无法访问，需要在方法内部创建对象并使用
* 该类可以直接访问外部类的成员，也可以访问方法内的局部变量

> 匿名内部类

* 匿名内部类本质上是一个特殊的局部内部类
* **前提：需要存在一个接口/类**
* 语法是`new 类名/接口名(){重写方法};`
* 匿名内部类是将（继承/实现）（方法重写）（创建对象）三个步骤放在了一步进行
* 使用场景：当方法的形式参数是接口或者抽象类时可以将匿名内部类作为实际参数进行传参

# 接口
> 接口概述

接口，在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 

* 接口使用**interface**关键字来定义`public interface 接口名{}`
* 接口通过**implements**关键字来实现接口`public classs 类名 implements 接口名{}`
* 实现接口的类需要需要重写接口中**所有**的抽象方法或者实现接口的类是抽象类
* 接口不能实例化
* 接口允许多实现，即一个类可以实现多个接口
* 接口中成员特点
  1. 成员变量：只能是常量，默认是**public static final**修饰
  2. 成员方法：只能是抽象方法，默认是**public abstract**修饰
  3. 没有构造方法

> JDK8中接口成员特点

* 默认方法
  1. 允许在接口中定义非抽象的方法，但是需要关键字**default**修饰，称为默认方法，作用是解决接口升级的问题
  2. 定义格式`public default 返回值类型 方法名(参数列表){}`
  3. public是默认的可以省略，但default不能省略
  4. 默认方法不是抽象方法，不强制重写，但是允许重写，**重写时去掉default关键字**
  5. 如果某个类实现了多个接口，接口中出现**相同方法声明的默认方法**，则必须对该方法重写
* 静态方法
  1. 允许在接口中定义静态方法，需要关键字**static**修饰
  2. 定义格式`public static 返回值类型 方法名(参数列表){}`
  3. public是默认的可以省略，static不能省略
  4. 接口中的静态方法只能通过`接口名.方法名()`来调用，不能通过实现该接口的类的类名和对象来调用

> 接口与接口的关系

1. 可以单继承，使用关键字**extends**修饰
2. 可以实现多继承，即一个接口可以继承多个接口
3. 多继承时如果被继承的多个接口中存在**相同方法声明的默认方法**，则需要在继承时重写该方法

# 枚举
Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。

Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 **,** 来分割。

```java
public enum 枚举类名{
    枚举项1,枚举项2,枚举项3;
}
```

> 特点

1. 所有枚举类都是Enum类的子类，所以枚举类可以使用Enum类中的方法
2. 可以通过**枚举类名.枚举项**去访问指定的枚举项
3. 每一个枚举项实际上是是该枚举类的一个对象
4. 枚举项可以有构造方法，但必须是**private**修饰，如果不提供无参构造，则必须在枚举项中使用有参构造
5. 枚举类还可以有成员变量，成员方法，抽象方法，但是抽象方法必须在枚举项中重写
6. **枚举类第一行必须是枚举项**

> 常用方法

| 方法名                                          | 说明                             |
| ----------------------------------------------- | -------------------------------- |
| String name()                                   | 获取枚举项名称                   |
| int ordinal()                                   | 获取枚举项索引                   |
| int compareTo(E o)                              | 返回与其他枚举项索引的差值       |
| String toString()                               | 返回枚举项名称                   |
| static <T> T valueOf(Class<T> type,String name) | 获取指定枚举类中指定名字的枚举项 |
| T[] values()                                    | 获取所有的枚举项                 |

# static关键字

> 概念

* static是静态的意思，是Java中的一个修饰符，可以修饰成员变量和成员方法
* static修饰的成员变量称为**静态变量**
* static修饰的成员方法称为**静态方法**

> 特点

* 被类的所有对象共享，这是我们判断是否使用静态关键字的条件
* 随着类的加载而加载，**优先于**对象存在，而对象是需要类被加载后才能创建
* 可以通过类名调用，也可以通过对象名调用，但是推荐使用类名

> 注意事项

* 静态方法只能访问静态成员，不能访问非静态成员
* 非静态方法可以访问静态成员，也可以访问非静态成员
* **静态方法中不能使用this关键字 **

# final关键字

* final可以修饰**类，方法，变量**
* final修饰类：表明该类是最终类，不能被继承
* final修饰方法：表明该方法是最终方法，不能被重写
* final修饰变量：
  1. 变量是基本数据类型：数据值不能改变
  2. 变量是引用类型：引用指向的地址不允许改变，但是地址里面的内容可以
* final修饰成员变量时建议直接赋值或者在构造方法中赋值

# 代码块

> 局部代码块

1. 位置：方法内
2. 特点：在**方法内代码块外**的地方访问不到代码块里边的变量
3. 作用：限定变量生命周期，及早释放，提高内存利用率

> 构造代码块

1. 位置：类中方法外
2. 特点：每次构造方法执行时，都会执行改代码块中的代码，并且**在构造方法执行前执行**
3. 作用：将多个构造方法中相同的代码抽取到代码块中，提高代码复用性

> 静态代码块

1. 位置：类中方法外
2. 特点：需要用**static**关键字修饰，随着类的加载而加载，**只执行一次**
3. 作用：在类加载时做一些数据初始化的操作

> <font color="red">**执行顺序**</font>

执行顺序（对于一个类中）：**静态代码块->父类构造方法->构造代码块->子类构造方法**

