---
title: MySQL高级篇-6-索引的数据结构
date: 2023-08-13 18:45:59
tags: 
  - MySQL
categories: 
  - Technology
---

# WHY 索引

索引是存储引擎用于快速找到数据记录的一种数据结构，MySQL进行数据查找时，首先看查询条件是否命中某条索引，符合则`通过索引查找`相关数据，如果不符合则需要`全表扫描`，直到找到符合的记录。创建索引目的是`减少磁盘I/O次数`，加快查询速度

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-54.jpg)

# 索引及其优缺点

 MySQL官方对索引的定义为： **索引（Index）是帮助MySQL高效获取数据的数据结构**

索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种索引引擎不一定支持所有索引类型。同时，存储引擎可以定义未每个表的`最大索引数`和`最大索引长度`。所有索引引擎支持每个表至少16个索引，总索引长度至少为256字节

> 优点

*  提高数据检索的效率，降低 数据库的IO成本 
*  通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 

*  在实现数据的 参考完整性方面，可以 加速表和表之间的连接，即对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。  

*  在使用分组和排序子句进行数据查询时，可以显著`减少查询中分组和排序的时间` ，降低了CPU的消耗 

> 缺点

* 创建索引和维护索引要`耗费时间`，并 且随着数据量的增加，所耗费的时间也会增加
* 索引需要占`磁盘空间` ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸
* 虽然索引大大提高了查询速度，同时却会`降低更新表的速度 `。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，降低数据的维护速度 

索引可以提高查询速度，但是会影响插入记录的速度。这种情况下，最好先删除表中的索引，然后插入数据，插入完成后再创建索引

# InnoDB中索引的推演

## 索引之前的查找

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = XXX;
```



> 在一个页中的查找

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录时可以根据搜索条件的不同分为两种情况：

* 以主键为搜索条件

  可以在页目录中使用`二分法`快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录

* 以其他列作为搜索条件

  因为在数据页中并没有对非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。这种情况下只能从`最小记录`开始`依次遍历`单链表中的每条记录，然后对比每条记录是不是符合搜索条件。

> 在很多页中查找

大部分情况下表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录：

1. 定位到记录所在的页
2. 从所在页内中查找相应的记录

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于并不能快速的定位到记录所在的页，所以`只能从第一个页` 沿着 `双向链表` 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 `超级耗时` 的。如果一个表有一亿条记录 呢？此时 `索引`应运而生。 

## 设计索引页

```sql
CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
	c3 CHAR(1),
    PRIMARY KEY(c1)
) ROW_FORMAT = Compact;    
```

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-55.jpg)

* `record_type`：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 

* `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，用 箭头来表明下一条记录 

* `各个列的值` ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 

* `其他信息`：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息 

 把一些记录放到页里的示意图就是： 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-56.jpg)

> 简单的索引设计方案 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-57.jpg)

>  InnoDB中的索引方案 

**迭代1次：目录项记录的页**

 从图可以看出，我们新分配了一个编号为30的页来专门存储目录项记录。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-58.jpg)

目录项记录和普通 用户记录 的**不同点**：  

* 目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0
* 目录项记录只有 主键值和页的编号 两个列，而普通的用户记录的列是用户自己定义的，可能包含 很 多列 ，另外还有InnoDB自己添加的隐藏列 
* 记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值 最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。  

**相同点**：

两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键 值进行查找时可以使用 二分法 来加快查询速度 

以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： 

1. 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 `12 < 20 < 209` ，所以定位到对应的记录所在的页就是页9。 

2. 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录 

**迭代2次：多个目录项记录的页** 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-59.jpg)

从图中看出，插入了一条主键值为320的用户记录之后需要两个新的数据页：

*  为存储该用户记录而新生成了`页31`

*  因为原先存储目录项记录的`页30的容量已满 `（我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的`页32`来存放`页31`对应的目录项 

 现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步 骤，以查找主键值为 20 的记录为例 ：

1. 确定`目录项记录页`

   现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。 

2. 通过目录项记录页`确定用户记录真实所在的页`

3. 在真实存储用户记录的页中定位到具体的记录 

**迭代3次：目录项记录页的目录页 **

如图生成一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-60.jpg)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-61.jpg)

**B+Tree** 

 一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 `0` 层， 之后依次往上加。

之前我们做了一个非常极端的假设：存放用户记录的页`最多存放3条记录` ，存放目录项 记录的页`最多存放4条记录` 。

其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 `100条用户记录` ，所有存放目录项记录的内节点代表的数据页可以存 放 `1000条目录项记录` ，那么： 

* 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放`100`条记录。 

* 如果B+树有2层，最多能存放 `1000×100=10,0000` 条记录。 
* 如果B+树有3层，最多能存放 `1000×1000×100=1,0000,0000` 条记录。 
* 如果B+树有4层，最多能存放 `1000×1000×1000×100=1000,0000,0000 `条记录。 

 所以一般情况下，我们` 用到的B+树都不会超过4层`（树的层次越低，IO次数越少） ，那通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又 因为在每个页面内有所谓的 `Page Directory `（页目录），所以在页面内也可以通过 二分法 实现快速 定位记录。  

## 常见索引

 索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。  

###  聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在叶子节点，所谓`索引即数据，数据即索引`）

**特点**：

1. 使用记录主键值的大小进行记录和页的排序
   * `页内`的记录是按照主键的大小顺序排成一个`单向链表` 
   * 各个存放`用户记录的页`也是根据页中用户记录的主键大小顺序排成一个`双向链表` 
   * 存放`目录项记录的页`分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个`双向链表`
2. B+树的`叶子节点`存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列） 

把具有这两种特性的B+树称为`聚簇索引`，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。这种聚簇索引并不需要在MySQL语句显式的使用`INDEX`语句创建，`InnoDB`存储引擎会自动为我们创建聚簇索引

**优点**： 

* 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快 
* 聚簇索引对于主键的`排序查找`和 `范围查找` 速度非常快 
* 按照聚簇索引排列顺序，查询显示一定范围数据的时，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 `节省了大量的io操作`  

**缺点**：

* `插入速度严重依赖于插入顺序` ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的ID列为主键** 
* `更新主键的代价很高 `，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**  
* `二级索引访问需要两次索引查找` ，第一次找到主键值，第二次根据主键值找到行数据 

**限制**：

* 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引，而MylSAM并不支持聚簇索引。
* 由于数据物理存储排序方式只能有一种，所以每个MysQL的`表只能有一个聚簇索引`。一般情况下就是该表的主键
* 如果没有定义主键，Innodb会选择`非空的唯一索引`代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。
* 为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量`选用有序的顺序id`，而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。

### 二级索引（辅助索引、非聚簇索引） 

`聚簇索引`只能在搜索条件是`主键值`时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。如果想以别的列作为搜索条件则需要建立不同的B+树，采用不同的排序规则

比如，用`c2`列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下



![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-62.jpg)

该B+树与上述聚簇索引不同：

* 使用记录c2列的大小进行记录和页的排序：
* 页内的记录是按照c2列的大小顺序排成一个`单向链表`
* 各个存放`用户记录的页也`是根据页中记录的c2列大小顺序排成一个`双向链表`
* 存放`目录项记录`的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个`双向链表`
* B+树的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值
* 目录项记录中不再是`主键+页号`的搭配，而变成了`c2列+页号`的搭配 



如果现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树。以查找c2列的值为4的记录为例，查找过程如下:

1. 确定`目录项记录`
   根据根页面，也就是页44，可以快速定位到目录项记录所在的页为页42（因为2< 4<9 )
2. 通过`目录项记录页`确定用户记录真实所在的页 
   在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2<4≤4，所以确定实际存储用户记录的页在页34和页35中
3. 在真实存储用户记录的页中定位到具体的记录 
   到页34和页35中定位到具体的记录。
4. 但是这个B+树的叶子节点中的记录只存储了`c2`和`c1`(也就是主键）两个列，所以我们必须再根据主键值
   去聚簇索引中再查找一遍完整的用户记录。

> 回表

 根据这个以c2列大小排序的B+树只能确定要查找记录的主键值，所以如果想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为`回表` ，也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！  

为什么还需要一次`回表`操作呢？直接把完整的用户记录放到叶子节点不OK吗？ 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-63.jpg)

如果把完整的用户记录放到叶子节点，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间
因为这种`按照非主键列`建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为`二级索引（secondary index）`，或者`辅助索引`。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2列建立的索引。
非聚簇索引的存在不影响数据在聚簇索引中的组织，因此一张表可以有多个非聚簇索引。



聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别:

* 聚簇索引的叶子节点存储的是`数据记录`，非聚簇索引的叶子节点存储的是`数据位置`。非聚簇索引不
  会影响数据表的物理存储顺序
* 一个表`只能有一个聚簇索引`，因为只能有一种排序存储的方式，但`可以有多个非聚簇索引`，也就是多个索引
  目录提供数据检索
* 使用聚簇索引时，数据的`查询效率高`，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索
  引低 

###  联合索引 

可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列的大小进行排序 

* 先把各个记录和页按照cz列进行排序。
* 在记录的c2列相同的情况下，采用c3列进行排序

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-64.jpg)

需要注意以下几点:

* 每条`目录项记录`都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序
* B+树`叶子节点`处的用户记录`由c2、c3和主键c1列`组成。

注意一点，以c2和c3列的大小为排序规则建立的B+树称为`联合索引`，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下:

* 建立`联合索引`只会建立如上图一样的1棵B+树。
* 为c2和c3列分别建女索引会分别以c2和c3列的大小为排序规则建立2棵B+树 

##  InnoDB的B+树索引的注意事项（重要）

### 根页面位置万年不动

**实际上B+树的形成过程：**

* 每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）时，都会为这个索引创建一个`根节点`页面。最开始表中没有数据时，每个B+树索引对应的`根节点`中既没有用户记录，也没有目录项记录
* 随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中 
* 当根节点中的可用`空间用完时`继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页
  * 比如`页a`中，然后对这个新页进行`页分裂`的操作，得到另一个新页，比如`页b`。
  * 这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到`页a`或者`页b`中，而`根节点`便升级为存储目录项记录的页

一个B+树索引的`根节点`自诞生起便不会再移动。只要我们对某个表建立一个索引，那么它的`根节点`的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出`根节点`的页号，从而来访问这个索引。



### 内节点中目录项记录的唯一性

B+树索引的内节点中目录项记录的内容是`索引列＋页号`的搭配，但是这个搭配对于二级索引来说有点儿不严谨。以index_demo表为例，假设这个表中的数据是这样的：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-65.jpg)

如果二级索引中目录项记录的内容只是`索引列＋页号`的搭配的话，那么为c2列建立索引后的B+树应该长这样:

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-66.jpg)



如果我们想新插入一行记录，其中`c1、c2、c3`的值分别是:`9、1、 'c'`，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：

由于`页3`中存储的目录项记录是由`c2列＋页号`的值构成的，`页3`中的两条目录项记录对应的c2列的值都是`1`，而我们`新插入的这条记录`的c2列的值也是`1`，那我们这条新插入的记录到底应该放到页4中，还是应该放到页5中



为了让新插入记录能找到自己在哪个页里，需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

* 索引列的值
* 主键值
* 页号

把`主键值`也添加到二级索引内节点中的目录项记录就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-67.jpg)

再插入记录`(9，1，'c')`时，由于`页3`中存储的目录项记录是由`c2列＋主键＋页号`的值构成的，可以先把新记录的`c2列`的值和`页3`中各目录项记录的`c2列`的值作比较

如果`c2列`的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的`c2列＋主键`的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，最后确定新记录应该被插入到页5中。



###  一个页面最少存储2条记录

InnoDB的`一个数据页至少可以存放两条记录`

# MyISAM中的索引方案

 B树索引适用存储引擎如表所示：  	

| 索引 / 存储引擎                | MyISAM | InnoDB | Memory |
| ------------------------------ | ------ | ------ | ------ |
| B-Tree索引（就是上述的B+Tree） | 支持   | 支持   | 支持   |

 即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。 MyISAM引擎使用`B+Tree`作为索引结构，叶子节点的data域存放的是`数据记录的地址` 

## MyISAM索引的原理

`InnoDB中索引即数据`，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而`MyISAM`的索引方案虽然也使用树形结构，但是却`将索引和数据分开存储`

* 将表中的记录`按照记录的插入顺序`单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并`没有刻意按照主键大小排序`，所以我们并不能在这些数据上使用二分法进行查找。
* 使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。`MyISAM`会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值＋数据记录地址`的组合。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-68.jpg)

设表一共有三列，假设我们以col1为主键，上图是一个MylSAM表的主索引（Primary key）示意。可以看出**MyISAM的索引文件仅仅保存数据记录的地址**。在MyISAM中，主键索引和二级索引（Secondary key）在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示:

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-69.jpg)

同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

## MyISAM 与 InnoDB对比

 MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的

* 在InnoDB存储引擎中，只需要根据主键值对`聚簇索引`进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次`回表`操作，意味着MyISAM中建立的索引相当于全部都是`二级索引`

* InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是`分离`的 ，索引文件仅保存数 据记录的地址
*  InnoDB的非聚簇索引data域存储相应记录`主键的值` ，而MyISAM索引记录的是`地址` 。 InnoDB的所有非聚簇索引都引用主键作为data域。 

* MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，InnoDB是通 过获取主键之后再去聚簇索引里找记录，比不上直接用地址去访问 

* InnoDB要求表`必须有主键`（ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-70.jpg)

#  索引的代价

**空间上的代价**：

每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用`16KB`的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。  

**时间上的代价** ：

每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。

而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。 

# MySQL数据结构选择的合理性 

从MySQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果我们能让索引的数据结构尽量减少硬盘的I/O操作，所消耗的时间也就越小。可以说，磁盘的 I/O操作次数对索引的使用效率至关重要。
查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MySQL衡量查询效率的标准就是磁盘IO次数。

## Hash

Hash本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。
Hash算法是通过某种确定性的算法（比如MD5、SHA1、SHA2、SHA3）将输入转变为输出。相同的输入水远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。

加速查找速度的数据结构，常见的有两类 

* 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是$O(log2N)$
* 哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是 $O(1)$

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-71.jpg)

采用Hash进行检索效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次I/o操作，从效率来说 Hash 比 B+树更快 
在哈希的方式下，一个元素 $k$ 处于 $h(k)$ 中，即利用哈希函数 $h$ ，根据关键字 $k$ 计算出槽的位置。函数 $h$ 将关键字域映射到哈希表 `T[0...m-1]`的槽位上。 

 ![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-72.jpg)

上图中哈希函数 $h$ 有可能将两个不同的关键字映射到相同的位置，这叫做 `碰撞 `，在数据库中一般采用 `链接法` 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-73.jpg)

> Hash结构效率高，那为什么索引结构要设计成树型呢？ 

* Hash索引仅能满足（=）（<>）和 IN 查询。如果进行`范围查询`，哈希型的索引，时间复杂度会退化为 $O(n)$ ;而树型的“有序""特性，依然能够保持 $O(log2N)$ 的高效率。
* Hash作为索引，数据的存储是`没有顺序的`，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序
* 对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询
* 对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是`索引列的重复值如果很多，效率就会降低`。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以Hash索引通常不会用到重复值多的列上 

> Hash索引适用存储引擎如表所示： 

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --------------- | ------ | ------ | ------ |
| HASH索引        | 不支持 | 不支持 | 支持   |

>  Hash索引的适用性 

* Hash索引存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型(Key-Value)数据库中，Redis存储的核心就是 Hash表。
* MysQL中的Memory存储引萌支持Hash存储，如果我们需要用到查询的临时表时，就可以选择Memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行`等值查询`时采用Hash索引是个不错的选择。
* 另外，InnoDB本身不支持 Hash索引，但是提供`自适应 Hash索引`。如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。下次查询时就可以直接找到这个页面的所在位置。这样让B+树也具备了Hash索引的优点。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-74.jpg)

 采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深时通过自适应 Hash 索引可以明显提高数据的检索效率。  



## 二叉搜索树

 如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的 

为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。 

##  AVL树

数据查询的时间主要依赖于磁盘IO的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 $O(log2n)$，当n比较大时，深度也是比较高的 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-75.jpg)

每访问一次节点就需要进行一次磁盘IO操作，对于上面的树来说，我们需要进行5次IO操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘IO操作次数多，会影响整体数据查询的效率。
针对同样的数据，如果我们把二叉树改成`M叉树`（M>2）呢?当M=3时，同样的31个节点可以由下面的三叉树来进行存储:

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-76.jpg)

## B-Tree 

B树的是多路平衡查找树，它的高度远小于平衡二叉树的高度。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-77.jpg)

B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，`M称为B树的阶`。每个磁盘块中包括了`关键字`和`子节点的指针`。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。

 一个 M 阶的 B 树（M>2）有以下的特性：  

1. 根节点的儿子数的范围是  $[2,M]$
2.  每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 $[ceil(\frac{M}{2}), M ]$

3.  叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为$[ceil(\frac{M}{2}), M ]$

4. 假设中间节点节点的关键字为：`Key[1], Key[2], …, Key[k-1]`，且关键字按照升序排序，即 `Key[i] < Key[i+1]`。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针， 即为：`P[1], P[2], …  P[k]`，其中 `P[1]` 指向关键字小于 `Key[1]` 的子树，`P[i] `指向关键字属于 `(Key[i-1], Key[i]）`的子树，`P[k]`指向关键字大于 `Key[k-1]`的子树 
5.  所有叶子节点位于同一层

 假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步： 

1. 与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1 

2.  按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； 

3.  按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9 

B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 `只要树的高度足够低，IO次数足够少，就可以提高查询性能` 。 

> 小结

* B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡
* 关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据，搜索有可能在非叶子节点结束
* 其搜索性能等价于在关键字全集内做一次二分查找

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-78.jpg)

## B+Tree

B+树也是一种多路搜索树，基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如 MysQL。相比于B-Tree，B+Tree适合文件索引系统。 B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。  

>  B+ 树和 B 树的差异： 

1.  有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1
2.  非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小） 
3.  非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，`非叶子节点既保存索引，也保存数据记录` 

4.  所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接 

> B+树与B树根本差异在于 **B+树的中间节点不直接存储树**

* **B+树查询效率更稳定**。B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时访问到非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。

* **B+树的查询效率更高**。这是因为通常B+树比B树`更矮胖`（阶数更大，深度更低），查询所需要的磁盘IO也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字
* 不仅是对单个关键字的查询上，**在查询范围上B+树的效率也比B树高**。所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，使得范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低 

> 为了减少IO，索引树会一次性加载吗

1. 数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。
2. 当我们利用索引查询时是不可能将全部几个G的索引都加载进内存的，能做的只能是逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点 

> B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-79.jpg)



> 为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-80.jpg)

> Hash 索引与 B+ 树索引的区别 思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？ 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/03-mysql-20230507-81.jpg)

## R树 

 R-Tree在MySQL很少使用，仅支持 `geometry数据类型` ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。

R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。 

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --------------- | ------ | ------ | ------ |
| R-Tree索引      | 支持   | 支持   | 不支持 |

