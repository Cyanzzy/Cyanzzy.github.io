---
title: JVM 内存与垃圾回收篇-4-对象实例化内存布局与方法定位
date: 2023-08-14 09:47:57
tags: 
  - JVM
categories: 
  - Language
swiper_index: 
---

# 对象实例化

## 对象的创建方式

> 使用`new`关键字

* 最常见的方式
* Xxx的静态方法
* XxxBuilder/XxxFactory的静态方法

> Class的`newInstance()`

反射的方式，只能调用空参的构造器，权限必须是`public`

> Constructor的`newInstance(Xxx)`

反射的方式，可以调用空参、带参的构造器，权限没有要求

> 使用`clone()`

不调用任何构造器，当前类需要实现`Cloneable`接口，实现`clone()`

> 使用反序列化

从文件中、网络中获取一个对象的二进制流

> 第三方 Objenesis

## 对象的创建步骤

> 1.判断对象对应的类是否加载、链接、初始化

* 虚拟机遇到一条`new`指令，首先去检查这个指令的参数能否在Metaspace的常量地中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在）。
* 如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。
* 如果没有找到文件，则抛出ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的Class类对象

> 2.为对象分配内存

* 首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。
* 如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

* 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。即所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存仅是把指针向空闲那边挪动一段与对象大小相等的距离。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。

* 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。即虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为"空闲列表（Free List）".

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

> 3.处理并发安全问题

采用CAS失败重试，区域加锁保证更新原子性；每个线程预分配一块TLAB（`-XX:+/-UseTLAB`）

> 4.初始化分配到的空间

所有属性设置默认值，保证对象实例字段不赋值时可以直接使用

给对象属性赋值的操作：

* 属性的默认初始化
* 显式初始化
* 代码块中初始化
* 构造器中初始化

> 5.设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的Hashcode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现

> 6.执行init方法进行初始化

在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。
因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。



# 对象的内存布局

> 对象头（Header）

对象头包含两部分运行时元数据（Mark Word）和类型指针

**运行时元数据：**

* 哈希值（HashCode）
* GC分代年龄
* 锁状态标志
* 线程持有的锁
* 偏向线程ID
* 偏向时间戳

**类型指针：**

指向类元数据`InstanceKlass`，确定该对象所属的类型

> 实例数据（Instance Data）

* 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下的本身拥有的字段）

* 规则：
  * 相同宽度的字段总是被分配在一起
  * 父类中定义的变量会出现在子类之前
  * 如果CompactFields参数为true（默认为true），子类的窄变量困难插入到父类变量的空隙

> 对齐填充（Padding）

不是必须的，仅仅起到占位符的作用

> 小结

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-74.jpg)

# 对象的访问定位

> JVM是如何通过栈帧的对象引用访问到其内部的对象实例的？

通过栈上的reference访问

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-75.jpg)

> 对象的访问方式--句柄访问

reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。



![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-76.jpg)

>  对象的访问方式--直接指针（Hotspot采用）

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-77.jpg)


