---
title: JUC-5-Java内存模型JMM
date: 2023-08-16 15:06:48
tags: 
  - Java
categories: 
  - Language
---

# JMM 概念

JVM规范中试图定义一种Java内存模型（Java Memory Model）来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能达到一致的内存访问效果

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-39.jpg)

JMM本身是一种**抽象的**概念并不真实存在`它仅仅描述的是一组约定或规范`，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术占都是围绕多线程的`原子性、可见性和有序性`展开的 

* 通过JMM 实现线程和主内存之间的抽象关系
* 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各平台下都能达到一致的内存访问效果

# JMM 三大特性

## 可见性

可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。



![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-40.jpg)

系统主内存**共享变量**数据修改被写入的时机是不确定的，**多线程并发下很可能出现"脏读"**，所以每个线程都有自己的工作内存、线程自己的工作内存中保存了该线程使用到的变量的**主内存副本拷贝**。

线程对变量的所有操作（读取，赋值等）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-41.jpg)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-42.jpg)



## 原子性

原子性是指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰

## 有序性

对于一个线程的执行代码而言，我们总认为代码的执行总是从上到下有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。

Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫**指令的重排序**。

JVM能根据处理器特性〈CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。

指令重排可以保证串行语义一致，但不能保证多线程间的语义也一致（即可能产生"脏读"），两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-43.jpg)

* 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致
* 处理器在进行重排序时必须要考虑指令之间的数据依赖性
* 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量无法确定能否保证一致性

# 多线程对变量的读写过程

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行

首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-44.jpg)

> JMM定义了线程和主内存之间的抽象关系

* 线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）
* 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本

> 小结

* 定义的所有共享变量都储存在物理主内存中
* 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）
* 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）
* 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）

# happens-before

在JMM中如果一个操作**执行的结果**需对另一个操作可见或者代码重排序，那么两个操作之间必须满足happens-before（先行发生）原则，逻辑上的先后关系

如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

> 次序规则

一个线程内按照代码顺序，写在前面的操作先行发生于写在后面的操作

> 锁定规则

一个`unlock`操作先行发生于后面（指时间上的先后）对同一个锁的lock操作

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-juc-20230402-45.jpg)

> volatile变量规则

对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的（“后面”同样是指时间上的先后 ）

> 传递规则

如果操作A先行发生于操作B，而操作B又先行发生于操作c，则可以得出操作A先行发生于操作C;

> 线程启动规则（start）

Thread对象的`start()`方法先行发生于此线程的每一个动作

> 线程中断规则（interruption）

* 对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生
* 可以通过`Thread.interrupted()`检测到是否发生中断
* 先调用`interrupt()`方法设置过中断标志位才能检测到中断发送

> 线程终止规则（termination）

线程中的所有操作都先行发生于对此线程的终止检测，可以通过`isAlive()`等手段检测线程是否已经终止执行。

> 线程终结规则（finalizer）

一个对象的初始化完成（构造函数执行结束）先行发生于它的`finalize()`方法的开始

> 总结

* 在Java里面Happens-Before 的语义本质上是一种可见性
* `A Happens-Before B`意味着A发生过的事情对B来说是可见的，无论A事件和B事件是否发生在同一个线程里

