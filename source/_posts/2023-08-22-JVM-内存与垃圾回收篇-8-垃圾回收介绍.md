---
title: JVM 内存与垃圾回收篇-8-垃圾回收介绍
date: 2023-08-22 15:35:29
tags: 
  - JVM
categories: 
  - Language
password: zzy   
message: 亲，能不能输入密码啊？
---
# 垃圾回收概述

> WHAT 垃圾

垃圾是指在**运行程序中没有任何指针指向的对象**，这个对象就是需要被回收的垃圾。

如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。

> WHY GC

* 对于高级语言来说，一个基本认知是如果不进行垃圾闻收，内存迟早都会被消耗完
* 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象
* 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有cc就不能保证应用程序的正常进行。而经常造成STw的Gc又跟不上实际的需求，所以才会不断地尝试对Gc进行优化

> Java垃圾回收机制

* 自动内存管理无需开发人员手动参与内存的分配与回收，降低内存泄漏和内存溢出的风险

* 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-105.jpg)

* 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收，其中Java堆是垃圾收集器的工作重点。
* 频繁收集Young区
* 较少收集Old区
  基本不动Perm区

# 垃圾回收相关概念

## System.gc() 的理解

* 在默认情况下，通过`System.gc( )`或者`Runtime.getRuntime( ).gc()`的调用，会显式触发`Full GC`，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存
* 然而`System.gc()`无法保证对垃圾收集器的调用
* JVM实现者可以通过`System.gc()`调用来决定JVM的GC行为。而一般情况
  下，垃圾回收应该是自动进行的，无须手动触发。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用`System.gc()`



## 内存溢出与内存泄漏

> 内存溢出

javadoc中对outofMemoryError的解释是没有空闲内存，并且垃圾收集器也无法提供更多内存 

**没有空闲内存说明Java虚拟机的堆内不够**：

* Java 虚拟机的堆内存设置不够：通过`-Xms、-Xmx`来调整
* 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）

> 内存泄漏

**严格来说，只有对象不会再被程序用到，但是GC又不能回收他们的情况，才叫内存泄漏。**

 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。（WEB项目将对象数据存储到应用程序或者会话级别，导致对象生命周期很长） 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outOfMemory异常，导致程序崩溃。 注意：这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小 

> 内存泄漏典例**（不要举引用计数法中循环引用栗子，因为Java根本不使用引用计数法）**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-115.jpg)

* 单例模式
  单例的生命周期和应用程序是一样长的，单例程序中如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生 
* 一些提供close的资源未关闭导致内存泄漏
  数据库连接（dataSourse.getconnection()），网络连接（socket）和io连接必须手动close，否则是不能被回收的 

## Stop the World

STW指GC事件发生过程中，会产生应加程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何响应。被STW中断的应用程序线程会在完成GC之后恢复

* STW事件和采用哪款GC无关，所有的GC都有这个事件
* 哪怕是G1也不能完全避免Stop-the-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间
* STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉
* 开发中使用`System.gc()`会导致STW

>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿 

* 分析工作必须在一个能确保一致性的快照中进行
* 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
* 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

## 垃圾回收的并行与并发

> 并发 concurrent

* 在操作系统中是指**一个时间段**中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行
* 并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段(时间区间)，然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-116.jpg)

> 并行 parallel

* 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPt可以执行另一个进程,
  两个进程互不抢占cPU资源，可以同时进行
* 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行
* 适合科学计算，后台处理等弱交互场景
  
  

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-117.jpg)

> 并发 V.S. 并行

* 并发指多个事情在同一时间段内同时发生，并发的多个任务之间是互相抢占资源的 
* 并行指多个事情在同一时间点上同时发生，并行的多个任务之间是不互相抢占资源的 
* 只有在多CPU或者一个CPU多核的情况中，才会发生并行；否则，看似同时发生的事情，其实都是并发执行的 

> 垃圾回收的并行与串行

* 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。（如ParNew、Parallel Scavenge、 Parallel Old）
* 串行（Serial）：
  * 相较于并行的概念，单线程执行
  * 如果内存不够，则程序暂停，启动JTVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-118.jpg)



> 垃圾回收的并发 

并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行，用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上（如CMS、G1）

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-119.jpg)

## 安全点与安全区域

> 安全点  Safepoint

程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为Safepoint

Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。

**GC发生时，如何检查所有线程都跑到最近的安全点停顿下来？**

* 抢先式中断：
  首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点     
* 主动式中断：
  设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起 

> 安全区 Safe Region

Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 Safepoint 。程序“不执行”的时线程无法响应JVM的中断请求“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒

对于这种情况就需要安全区域解决。安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的

 **实际执行时**

* 当世线程运行到Safe Region的代码时，首先标识已经进入Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程;
* 当线程即将离开Safe Region时，会检查VM是否已经完成GC，如果完成则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止 

## 再谈引用

Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用

* 强引用（StrongReference）：指在程序代码之中普遍存在的引用赋值，类似`Object obj=new Object()`这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
* 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常
* 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
* 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

> 强引用--不回收

* 在Java中最常见的引用类型是强引用，即最常见的普通对象引用，也是默认的引用类型 
* 当在Java中使用`new`操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用 
* 强引用的对象是**可触及的**，垃圾收集器就永远不会回收掉被引用的对象
* 对于一个普通的对象，如果没有其他的引用关系，只要超过引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集，当然具体回收时机还是要看垃圾收集策略。
* 相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。因此**强引用是造成Java内存泄漏的主要原因之一。**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/06-jvm-20230802-120.jpg)

1. 强引用可以直接访问目标对象 
2. 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象 
3. 强引用可能导致内存泄漏 



> 软引用--内存不足即回收

* 软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收（第一次回收是不可触及的对象），如果这次回收还没有足够的内存，才会抛出内存溢出异常。

* 软引用通常用来实现内存敏感的缓存。比如，高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
* 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列
* 当把内存足够，不会回收软引用的可达对象；当内存不够，会回收软引用的可达对象

> 弱引用--发现即回收

* 弱引用也是用来描述那些非必需对象，**只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。**在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。
* 垃圾回收器的线程通常优先级很低，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。
* 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。
* **软引用、弱引用都非常适合来保存那些可有可无的缓存数据。**如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

* **弱引用对象与软引用对象的最大不同**：当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。

> 虚引用--对象回收跟踪

* 虚引用也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个
* 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收
* 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的`get()`方法取得对象时，总是null
* **为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程**

* 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
* 虚引用可以跟踪对象的回收时间，可以将一些资源释放操作放置在虚引用中执行和记录 



> 终结器引用

* 它用以实现对象的`finalize()`方法
* 无需手动编码，其内部配合引用队列使用。
* 在GC时终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的`finalize ()`方法，第二次Gc时才能回收被引用对象。







