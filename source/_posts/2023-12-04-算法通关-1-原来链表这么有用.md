---
title: 算法通关-第 1 关：原来链表这么有用
date: 2023-12-04 20:56:04
tags: 
  - DataStructure
categories: 
  - Algorithm
---

# 青铜挑战--手撕链表

> 内容大纲

* Java 构造链表
* 链表增删改查

## 单链表

单链表包含若干节点，每个节点具有指向后继结点的 next 指针，最后一个节点的 next 指向 NULL。
![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-122.png)

> 正确示范

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-123.png)

> 错误示范

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-124.png)

## 虚拟节点

> 节点和头节点

链表中每个节点都由值和指向下一个节点的地址组成，对于单链表，第一个元素节点称为头节点

> 虚拟节点

* 即 `dummyNode`，其 `next` 指针指向 `head`
* 如果获取 `head` 节点，或者从方法里返回时，使用 `dummyNode.next`
* `dummyNode` 的 `val` 不会被使用，通常初始化成 0 或 -1

## 创建链表

JVM 下栈区存放实际对象的引用地址，堆区存放创建的对象：

```java
public class Course {
    Teacher teacher;
    Student student;
}
```
此时的 teacher 和 student 就是指向堆的引用，若我们这样定义：

```java
public class Course {
    int val;
    Course next;
}
```
此时 next 指向下一个同为 Course 类的对象

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-125.png)

这里通过栈中引用找到 `val(1)`，然后 `val(1)` 节点存放指向 `val(2)` 的地址，`val(3)` 存放指向 `val(4)` 的地址。

根据面向对象理论，Java 规范的链表定义：

```java
public class ListNode {

    private int data;
    private ListNode next;

    public ListNode(int data) {
        this.data = data;
    }
    
    public int getData() {
        return data;
    }
    
    public void setData(int data) {
        this.data = data;
    }
    
    public ListNode getNext() {
        return next;
    }

    public void setNext(ListNode next) {
        this.next = next;
    }
}
```

> LeetCode 链表结构

```java
public class ListNode {

    private int val;
    private ListNode next;

    ListNode(int x) {
        this.data = x;
        next = null;
    }

}
ListNode listnode = new ListNode(1);
```

## 链表增删改查

> 遍历链表

对于单链表，无论进行何操作，操作后是否还能找到表头非常重要。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-126.png)

```java
public int getListLength(ListNode head) {
    int length = 0;
    ListNode node = head;
    
    while (node != null) {
        length++;
        node = node.next;
    }
    return length;
} 
```

> 插入链表

单链表的插入需要考虑头部、中部、尾部情况。

**头部插入**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-127.png)

**中间插入**

在中间位置插入，必须遍历找到插入位置，然后将当前位置接入到前驱节点和后继节点之间，但是到了该位置后无法获取前驱节点，为此我们在目标节点的前一个位置停下，使用 `cur.next` 值进行判断：
例如我们在下图中 7 的前面插入，当 `cur.next = node(7)` 就应该停下来，具体操作如下。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-128.png)

**尾部插入**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-129.png)

**方法实现**

```java
/**
 * 链表插入
 *
 * @param head 链表头节点
 * @param nodeInserted 待插入节点
 * @param position 待插入位置，从 1 开始
 * @return 插入后得到的链表头节点
 */
public ListNode insertListNode(ListNode head, ListNode nodeInserted, int position) {
    // 边界判断
    if (head == null) {
        return nodeInserted;
    }
    // 已经存放的元素个数
    int size = getListLength(head);
    // 边界判断
    if (position > size + 1 || position < 1) {
        System.out.println("位置参数越界");
        
        return head;
    }
    // 头部插入
    if (position == 1) {
        nodeInserted.next = head;
        head = nodeInserted;
        
        return head;
    }
    ListNode pNode = head;
    int count = 1;
    // 由于 position 被 size 限制住，无需考虑 pNode = null
    while (count < position - 1) { // 寻找插入位置
        pNode = pNode.next;
        count++;
    }
    // 插入节点
    nodeInserted.next = pNode.next;
    pNode.next = nodeInserted;
    
    return head;
}
```
扩展：若链表要求单调递增，请将元素插入合适位置，并使链表仍程单调递增，请写出算法实现？

> 链表删除

单链表的删除需要考虑头部、中部、尾部情况。

**删除表头节点**
一般执行 `head = head.next` 即可。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-130.png)


**删除表尾节点**

找到待删除节点的前驱节点，然后执行 `cur.next = null` 即可。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-131.png)


**删除中间节点**

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-132.png)

**方法实现**

```java
/**
 * 删除节点
 *
 * @param head 链表头节点
 * @param position 待删除节点位置，从 1 开始
 * @return 删除后的链表头节点
 */
public ListNode deleteListNode(ListNode head, int position) {
    // 边界判断
    if (head == null) {
        return null;
    }
    int size = getListLength(head);
    // 边界判断
    if (position > size || position < 1) {
        System.out.println("位置越界");
        return head;
    }

    // 头部删除
    if (position == 1) {
        return head.next;
    } else { // 其他情况
        ListNode cur = head;
        int count = 1;
        while (count < position - 1) { // 寻找删除位置
            cur = cur.next;
            count++;
        }
        // 删除节点
        ListNode curNode = cur.next;
        cur.next = curNode.next;
    }
    
    return head;
}
```
扩展：若链表是有序的，请删除某元素，并使链表仍程单调递增，请写出算法实现？


## 挑战思考

1. Java 如何构造链表？
2. 链表增加元素，头部、中间、尾部分别会有什么问题，如何处理？
3. 链表删除元素，头部、中间、尾部分别会有什么问题，如何处理？