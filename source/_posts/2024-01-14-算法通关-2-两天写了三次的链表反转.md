---
title: 算法通关-第 2 关：两天写了三次的链表反转
date: 2024-01-14 21:11:45
tags: 
  - DataStructure
categories: 
  - Algorithm
---

# 青铜挑战--手写链表反转

> 内容大纲

1. 掌握带虚拟头节点的链表反转
2. 掌握不带虚拟节点的链表反转

> 题目

【LeetCode 206】：给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

> 参考资料

[链表3.透彻理解链表反转以及拓展问题](https://www.bilibili.com/video/BV1Qz4y1c7Wv/)
[链表6：大厂如何考链表反转](https://www.bilibili.com/video/BV1vw411P7Gp/)

## 建立虚拟头节点辅助反转

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-144.png)

```java
// 带有虚拟节点的反转
public ListNode reverseList(ListNode head) {

    // 接上虚拟节点解决问题
    ListNode L = new ListNode(-1);
    L.next = head;
    
    // 断链操作，为头插法做铺垫
    L.next = null;

    // 当前指针 p
    ListNode p = head;
    while (p != null) {
        // 哨兵指针 q
        ListNode q = p.next; // 保存后继
        p.next = L.next;
        L.next = p;
        p = q;
    }
    return L.next;
}
```
## 直接操作链表实现反转（常考）

> 反转前后的结构和指针位置：

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-145.png)

> 执行期间示意图

- `cur` 指向旧链表的首节点
- `prev` 表示已经调整好的新链表的表头
- `next` 表示下一个需要调整的节点
- `cur` 和 `prev` 是两个表的表头，移动过程中 `cur` 经过一次中间状态后，又重新变成两个链表的表头

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/algorithm-20230213-146.png)


```java
public ListNode reverseList(ListNode head) {

    // pre 表示已经调整好的新链表的表头
    ListNode prev = null;
    // cur 指向旧链表的首节点
    ListNode cur = head;

    while (cur != null) {
        // next 表示下一个需要调整的节点
        ListNode next = cur.next;
        // 反转逻辑
        cur.next = prev;
        prev = cur;
        // 转向下一个待处理的节点
        cur = next;
    }
    return prev;
}
```

## 递归反转

```java
/**
 * 以链表1->2->3->4->5举例
 * 
 * @param head
 * @return
 */
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        /*
            直到当前节点的下一个节点为空时返回当前节点
            由于5没有下一个节点了，所以此处返回节点5
            */
        return head;
    }
    //递归传入下一个节点，目的是为了到达最后一个节点
    ListNode newHead = reverseList(head.next);
            /*
        第一轮出栈，head为5，head.next为空，返回5
        第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，
                    把当前节点的子节点的子节点指向当前节点
                    此时链表为1->2->3->4<->5，由于4与5互相指向，所以此处要断开4.next=null
                    此时链表为1->2->3->4<-5
                    返回节点5
        第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，
                    此时链表为1->2->3<->4<-5，由于3与4互相指向，所以此处要断开3.next=null
                    此时链表为1->2->3<-4<-5
                    返回节点5
        第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，
                    此时链表为1->2<->3<-4<-5，由于2与3互相指向，所以此处要断开2.next=null
                    此时链表为1->2<-3<-4<-5
                    返回节点5
        第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，
                    此时链表为1<->2<-3<-4<-5，由于1与2互相指向，所以此处要断开1.next=null
                    此时链表为1<-2<-3<-4<-5
                    返回节点5
        出栈完成，最终头节点5->4->3->2->1
        */
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

# 白银挑战--链表反转的拓展问题

> 内容大纲

1. 指定区间反转
2. 两两交换链表中的节点
3. 单链表加 1
4. 链表加法

## 指定区间反转

## 两两交换链表中的节点

## 单链表加 1
## 链表加法
## 回文链表

# 黄金挑战--K组反转链表