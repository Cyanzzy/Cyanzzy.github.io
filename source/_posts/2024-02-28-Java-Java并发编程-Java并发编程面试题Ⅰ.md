---
title: Java 并发编程常见面试题总结 Ⅰ
date: 2024-02-28 22:14:35
tags: 
  - Java
categories: 
  - Interview
password: zzy   
message: 仅管理员可见
---

#  线程和进程

## 进程

1. 进程是操作系统中的一个执行实例
2. 进程是操作系统分配资源的基本单位，进程拥有独立的内存空间和系统资源
3. 进程之间具有隔离性，每个进程都是独立运行的，它们之间不会相互影响 
4. 进程的创建、销毁和切换都需要较大的时空开销
5. 进程之间的通信需要通过进程间通信（IPC）机制来实现（管道、消息队列、共享内存）

## 线程

1. 线程是进程划分成的更小的运行单位
2. 线程是由操作系统调度执行的基本单位，共享进程的资源
3. 线程的创建、销毁和切换的成本远远小于进程
4. 同一个进程中的线程共享进程的地址空间和系统资源，但拥有独立的执行流程

## 线程与进程的关系

> 面试角度

1. 进程是资源分配的基本单位，而线程是CPU调度的基本单位 
2. 进程之间相互独立，线程之间共享进程的资源 
3. 一个进程可以包含多个线程。 同一进程中的多个线程共享相同的代码和数据 

> JVM 角度

一个进程中可以有多个线程，多个线程共享进程的堆和 方法区（JDK1.8 之后的元空间）资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/Java-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-01.png)

 

>  为什么**程序计数器**、**虚拟机栈**和**本地方法栈**是线程私有的，而堆和方法区是线程共享的呢？ 

### 线程私有区域：

 **程序计数器（Program Counter Register）：** 

- 程序计数器是每个线程独有的，它用于存储当前线程执行的字节码行号。每个线程执行的代码是独立的，因此需要一个独立的程序计数器来记录线程的执行位置。
- 线程切换时，程序计数器也会随之切换，确保线程独立地执行。程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。



 **虚拟机栈（Java Virtual Machine Stack）：** 

- 虚拟机栈也是线程私有的，每个线程都有自己的虚拟机栈。
- 虚拟机栈存储了线程执行方法的局部变量表、操作数栈、动态链接、方法出口等信息。不同线程之间的方法调用和局部变量是相互独立的，因此需要线程私有的虚拟机栈。



 **本地方法栈（Native Method Stack）：** 

- 本地方法栈类似于虚拟机栈，用于执行本地方法（Native Method）的栈空间。 
- 本地方法栈也是线程私有的，因为不同线程可能调用不同的本地方法，这些本地方法的执行过程是相互独立的。

**本地方法栈**  和虚拟机栈所发挥的作用非常相似，区别是： 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

 所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。 

### 线程共享区域：

 **堆（Heap）：** 

-  对象的创建、销毁和垃圾回收都发生在堆中。(几乎所有对象都在这里分配内存)
-  堆是用于存储对象实例的区域，是所有线程共享的。在堆中分配的对象可以被所有线程访问，因此需要是线程共享的。  

 **方法区（Method Area）：** 

-  方法区也是线程共享的，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 
-  不同线程之间可能会共享相同的类信息，因此需要线程共享的方法区。 

### 线程私有和线程共享的优势：

 **线程私有：** 

- 提高线程的隔离性，一个线程的操作不会直接影响其他线程。
- 线程切换时不需要考虑同一区域的互斥问题，减少了同步的需求，提高了并发性能。

 **线程共享：** 

- 节省内存空间，多个线程可以共享一份方法区和堆，避免重复存储类信息和对象实例。
- 共享的数据区域可以通过一些同步机制确保线程安全，例如在堆中使用同步机制确保对象的线程安全访问。

#  Java 线程和操作系统线程区别

> 【推荐】Java 线程和操作系统线程区别

**创建和绑定的时机**：

- Java 线程是在 Java 程序中通过 Thread 类创建的，而操作系统线程是由操作系统内核创建和管理的
- Java 线程在创建后会与 JVM 线程绑定，而 JVM 线程会在需要时与操作系统线程绑定。

**线程模型**：

- Java线程模型是基于操作系统线程模型的，具体实现依赖于操作系统的线程库。
- 例如，在 Windows 中，Java 线程使用 Win32 线程库来管理线程，采用一对一的线程模型，即每个 Java 线程对应一个操作系统线程。

**调度和切换开销：**

- Java 线程的调度和切换是由 JVM 负责的，而操作系统线程的调度和切换是由操作系统内核负责的
- 由于 Java 线程是在用户空间中进行调度和切换，相对于操作系统线程来说，开销较小。

**线程数量限制**：

- 操作系统线程是由操作系统内核创建和管理的，因此操作系统对线程数量有一定的限制
- Java 线程是在 JVM 中创建和管理的，因此可以创建更多的 Java 线程

**线程同步和通信：**

- Java线程提供了丰富的线程同步和通信机制，如 synchronized 关键字、wait() 和 notify() 方法等，使得线程之间的同步和通信更加方便
- 操作系统线程通常使用操作系统提供的同步和通信机制，如互斥锁、条件变量等 

>  【扩展】用户线程和内核线程

- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。

 用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。 

>  【扩展】线程模型是用户线程和内核线程之间的关联方式
>
>  常见的线程模型有这三种： 

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/Java-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-02.png)

> 【扩展】

  Java 线程和操作系统线程的关系：**现在的 Java 线程的本质其实就是操作系统的线程**。 

- 在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。

- Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。 具体可以参考 R 大的回答: [JVM 中的线程模型是用户级的么？](https://www.zhihu.com/question/23096638/answer/29617153) 



#  并发与并行的区别

- **并发**：两个及两个以上的作业在 **同一时间段** 内执行。
- **并行**：两个及两个以上的作业在 **同一时刻** 执行。

 最关键的点是：是否是 **同时** 执行 

#  同步和异步的区别

> 同步

- 同步指的是按照顺序依次执行，一个任务的执行会阻塞后续任务的执行，直到前一个任务完成 
- **阻塞模型：** 在同步模型中，当一个任务执行时，会阻塞后续任务的执行，直到当前任务完成。 
- **顺序执行：**  同步操作是顺序执行的，每个任务按照其调用的顺序执行。 
- **调用者主动等待：** 调用者需要主动等待被调用者的完成，一直等到任务执行完毕。 
- **适用场景：**  同步适用于简单的、顺序执行的任务，确保任务按照预定的顺序执行。 

> 异步

-  异步指的是不按照顺序执行，一个任务的执行不会阻塞后续任务的执行。 
-  **非阻塞模型：**  在异步模型中，一个任务的执行不会阻塞后续任务，后续任务可以继续执行。
-  **回调机制：** 异步操作通常采用回调（Callback）机制，即在任务完成时通过回调通知调用者。   
-  **调用者不等待：**调用者不需要等待被调用者的完成，可以继续执行其他任务。 
-  **适用场景：**  异步适用于需要处理大量并发或需要等待时间较长的任务，以提高系统的性能和响应性。 

> 小结

- 同步和异步主要区别在于任务执行时是否阻塞后续任务以及调用者是否等待任务完成。 
- 同步是顺序执行，一个任务执行完才能执行下一个任务，调用者需要主动等待任务完成。
- 异步是非阻塞的，任务的执行不会阻塞后续任务，调用者不需要等待，而是通过回调等机制获取任务完成的通知。
- 同步适用于简单的、顺序执行的任务，而异步适用于需要处理并发或等待时间较长的任务。 

#  多线程

## 多线程的优劣

> 优势

-  **并发执行：**  多线程允许多个任务在同一时间段内并发执行，提高了程序的运行效率和响应速度。 
-  **资源共享：**  多线程可以共享相同进程的资源，包括内存空间、文件句柄等，减少了资源的浪费。 

-  **任务分解：**  多线程允许程序将任务拆分成多个子任务并分配给不同的线程，提高了程序的并发性和整体性能。 

-  **资源利用： 多线程可以更有效地利用多核处理器，提高硬件资源的利用率。 ** 

> 劣势

- **并发问题**：多个线程同时访问和修改共享数据，可能导致不可预测的结果。 
- **死锁问题**：多线程的不当使用可能导致死锁，即两个或多个线程无法继续执行，因为它们在等待对方释放资源。 
- **资源消耗**： 线程的创建和管理本身会消耗系统资源，如果线程数量过多，可能会导致资源消耗过大。 
- **安全问题**： 多线程可能引发一些安全性问题，例如竞争条件和线程安全问题，需要额外的处理和保障。 
- **性能损失**：在某些情况下，多线程并不一定会带来性能提升，甚至可能因为线程间的切换和同步操作而导致性能损失。 

> 如何理解线程安全和不安全？

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够**保证其正确性和一致性**：

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

## 创建多线程的方式

> **继承Thread类**

1. 自定义类继承Thread类
2. 在自定义类中重写 **run()** 方法
3. 创建自定义类的对象
4. 启动线程

```java
public class Test {
    public static void main(String[] args){
        // 创建线程
        MyThread thread = new MyThread();
        // 启动线程
        thread.start();
    }
}

class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(i);
        }
    }
}
```

> **实现 Runable 接口**

1. 自定义类实现 Runnable 接口
2. 在自定义类中重写 **run()** 方法
3. 创建自定义类对象
4. 创建Thread类对象，把自定义类对象作为构造方法的参数
5. 启动线程

```java
public class Test {
    public static void main(String[] args){
        // 创建线程
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        // 启动线程
        thread.start();
    }
}

class MyRunnable implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(i);
        }
    }
}
```

> **Callable 接口和 FutureTask 类**

1. 自定义类实现 Callable 接口
2. 在自定义类中重写 **call()** 方法
3. 创建自定义类的对象
4. 创建 FutureTask 类的对象，把自定义类的对象作为构造方法的参数
5. 创建 Thread 类的对象，把 FutureTask 对象作为构造方法的参数
6. FutrueTask 中的 **get()** 方法可以获取线程执行完后的返回值，如果在线程开启前调用该方法，那么该程序会一直停留在该代码处

```java
public class Test {
    public static void main(String[] args){
        // 创建线程1
        MyCallable myCallable = new MyCallable();
        FutureTask<String> futureTask = new FutureTask<>(myCallable);
        Thread thread = new Thread(futureTask);
        // 启动线程
        thread.start();
        // 获取执行完的结果
        System.out.println(futureTask.get());
    }
}

class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        for(int i = 0;i < 100;i++){
            System.out.println(i);
        }
        // 返回值表示线程执行完返回的结果
        return "该线程执行完啦";
    }
}
```

| 方式                               | 优点                                            | 缺点                                                         |
| ---------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ |
| 继承Thread类                       | 编程简单，run()方法中能直接使用Thread类中的方法 | 扩展性差，不能继承其他类                                     |
| 实现Runnable接口或实现Callable接口 | 扩展性强，实现接口的同时还能继承其它类          | 编程复杂，run()方法或者call()方法中不能直接使用Thread类中的方法 |

#  单核 CPU 上运行多个线程效率一定会高吗？

单核 CPU 同时运行多个线程的效率是否会高，**取决于线程的类型和任务的性质。** 

> 一般来说，有两种类型的线程：CPU 密集型和 IO 密集型。

*  CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。 
*  IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。 

> 在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。

* 如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，会降低效率。
* 如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，会提高效率。

 因此，对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。 

#  线程的生命周期和状态

 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换：

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，已经创建线程但未调用 `start()` 。                  |
| RUNNABLE     | 运行状态，已经调用`start()`正在运行的状态。                  |
| BLOCKED      | 阻塞状态，需要等待锁释放。                                   |
| WAITING      | 等待状态，该线程需要等待其他线程做出通知或中断               |
| TIME_WAITING | 超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。 |
| TERMINATED   | 终止状态，该线程已经运行完毕。                               |



> Java 线程状态变迁图 |  [《Java 并发编程的艺术》中关于线程状态的三处错误 ](https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w)

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/Java-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-03.png)

*  创建线程后它将处于 **NEW（新建）** 状态，  调用 `start()` 方法后开始运行，  线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于  **RUNNING（运行）** 状态。 

- 当线程执行 `wait()`方法后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。
- **TIMED_WAITING(超时等待)** 状态相当于在等待状态的基础上增加超时限制，比如通过方法或 方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。
- 当线程进入 `synchronized` 方法/块或者调用 `wait` 后 （被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。 
- 线程在执行完 `run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

>  在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：[HowToDoInJava](https://howtodoinjava.com/)：  [Java Thread Life Cycle and Thread States](https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/) ） ，所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。
>
>  **为什么 JVM 没有区分这两种状态呢？**  （摘自：[Java 线程运行怎么有第六种状态？ - Dawell 的回答](https://www.zhihu.com/question/56494969/answer/154053599) ）
>
>  现在的时分多任务操作系统架构通常都是用所谓的“时间分片”方式进行抢占式轮转调度。这个时间分片通 常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。**线程切换的如此之快，区分这两种状态就没什么意义了。** 
>
>  ![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/Java-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-04.png)

[线程的几种状态你真的了解么](https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w)

#   线程上下文切换

 线程上下文切换是指在一个处理器上执行的线程被暂停，然后另一个线程在同一个处理器上开始执行的过程。上下文切换是多任务操作系统中的常见现象，其中多个线程或进程共享同一个处理器。 

> 线程上下文切换的触发条件：

- **抢占式调度：**  在抢占式调度中，操作系统可以在一个线程执行的时间片结束时，强制将该线程暂停并切换到另一个线程。 
- **线程主动释放：**  一个线程在执行时，可以主动放弃执行权，通过让出CPU的方式触发线程上下文切换。 

- **外部事件发生：**  外部事件，如硬件中断或信号的到达，可能导致当前执行的线程被中断，进而触发上下文切换。 

> 线程上下文切换的过程：

- **保存当前线程上下文：**  当一个线程被切换出去时，其当前的上下文信息（寄存器状态、程序计数器等）需要被保存。 
- **加载下一个线程的上下文：**  当一个新的线程被切换进来时，它的上下文信息需要被加载到处理器中。 

> 线程上下文切换的开销：

- **寄存器保存和加载：**  上下文切换需要保存当前线程的寄存器状态，然后加载新线程的寄存器状态。 
- **内核态和用户态切换：**  上下文切换可能涉及从内核态切换到用户态，或反之，这会引入一些额外的开销。
- **页表切换：**如果线程涉及到内存分页，上下文切换可能会导致页表的切换，增加了内存访问的开销。
- **缓存失效：**  当一个新线程开始执行时，它的数据可能不在缓存中，导致缓存失效，需要重新加载数据。 

> 影响性能的因素：

- **线程数量：**  线程数量的增加会导致更频繁的上下文切换，从而可能降低系统的性能。 
- **任务切换频率：**  如果线程的时间片设置得过小或任务切换过于频繁，上下文切换的开销可能会显著增加。 
- **硬件支持：**  不同的硬件架构和操作系统对上下文切换的实现方式和效率可能有差异。 
- **系统负载：**  系统负载较高时，上下文切换的频率可能会增加，影响整体性能。 

#   线程死锁

## 死锁演示

死锁（Deadlock）是在多线程或多进程环境中的一种资源争夺的现象，其中两个或多个进程或线程互相等待对方释放持有的资源而无法继续执行。这种情况会导致程序永久性地停滞。 

> 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/Java-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-05.png)

 **死锁演示：**

```java
public class DeadLockDemo {
    private static Object resource1 = new Object(); // 资源 1
    private static Object resource2 = new Object(); // 资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 A").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 B").start();
    }
}

// outputs
Thread[线程 A,5,main] get resource1
Thread[线程 B,5,main] get resource2
Thread[线程 A,5,main] waiting get resource2
Thread[线程 B,5,main] waiting get resource1
```

- 线程 A 通过 `synchronized (resource1)` 获得 `resource1` 的监视器锁，然后通过`Thread.sleep(1000);`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 `resource2` 的监视器锁。 

- 线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。 

## 死锁产生必要条件： 

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**： 已经分配给进程或线程的资源不能被抢占，只能由持有它的线程释放。 
4. **循环等待条件**： 存在一个资源的循环链，使得每个进程或线程都在等待一个在链中的其他成员所持有的资源。 



##  预防死锁

> 破坏死锁的产生的必要条件即可： 

1. **破坏请求与保持条件**：一次性申请所有的资源。

2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## 避免死锁

 避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。 

**安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称  <P1、P2、P3.....Pn>  序列为安全序列。

> 我们对线程 B 的代码修改成下面这样就不会产生死锁了。 

```java
new Thread(() -> {
    synchronized (resource1) {
        System.out.println(Thread.currentThread() + "get resource1");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread() + "waiting get resource2");
        synchronized (resource2) {
            System.out.println(Thread.currentThread() + "get resource2");
        }
    }
}, "线程 B").start();

Thread[线程 A,5,main] get resource1
Thread[线程 A,5,main] waiting get resource2
Thread[线程 A,5,main] get resource2
Thread[线程 B,5,main]get resource1
Thread[线程 B,5,main]waiting get resource2
Thread[线程 B,5,main]get resource2
```

我们分析一下上面的代码为什么避免了死锁的发生?

- 线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。
- 然后线程 1 再去获取 resource2 的监视器锁，可以获取到。
- 然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。
- 这样就破坏了破坏循环等待条件，因此避免了死锁。

#  sleep() 方法和 wait() 方法

## sleep() 方法

-  `sleep()` 方法属于 `Thread` 类，用于让当前线程休眠一段指定的时间。它不会释放持有的锁。 

-  `sleep()` 是静态方法，直接由 `Thread` 类调用。 
-  休眠期间，线程不会释放其锁，其他线程无法获取锁。 
-  主要用于控制线程执行的时间间隔。 

```java
try {
    // 休眠1000毫秒（1秒）
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```



## wait() 方法

-  `wait()` 方法属于 `Object` 类，用于将当前线程置于等待状态，直到其他线程调用相同对象的 `notify()` 或 `notifyAll()` 方法唤醒它 
-  `wait()` 是非静态方法，必须在同步块中调用。 

-  调用 `wait()` 会使当前线程释放锁，其他线程可以获取同一对象上的锁。 
-  通常与 `notify()` 或 `notifyAll()` 一起使用，用于线程之间的协调与通信。 

>  **区别**：

- `sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。



#  为什么 wait() 方法不定义在 Thread 中

- `wait()` 是让获得**对象锁**的线程实现等待，会自动释放当前线程占有的对象锁。
- 每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的**对象锁**并让其进入 WAITING 状态，自然是**要操作对应的对象**（`Object`）而非当前的线程（`Thread`）。

> 类似的问题：**为什么 `sleep()` 方法定义在 `Thread` 中？**

因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

#  可以直接调用 Thread 类的 run 方法吗

 在 Java 中，可以直接调用 Thread 类的 `run()` 方法，但是需要理解 `run()` 方法和 `start()` 方法之间的区别。 

> 直接调用 `run()` 方法：

```java
Thread myThread = new MyThread();
myThread.run();
```

 这样调用实际上并不会创建新的线程，而只是在当前线程中执行 `run()` 方法。这种方式与普通的方法调用没有本质区别，不会启动新的线程，而是在当前线程的调用栈上执行 `run()` 方法。 

> 使用 `start()` 方法：

```java
Thread myThread = new MyThread();
myThread.start();
```

 这是启动线程的正确方式。`start()` 方法会创建一个新的线程，并在新的线程中调用 `run()` 方法。这样可以实现多线程的并发执行。 

*  new 一个 `Thread`，线程进入了新建状态。
*  调用 `start()`方法，  会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。  
*  `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。  
*  但是，直接执行 `run()` 方法会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 

> 结论

-  如果直接调用 `run()` 方法，不会创建新的线程，而是在当前线程中执行 `run()` 方法的代码。这样做失去了多线程的优势，因为所有的任务都在同一个线程中执行，不会并发执行。 
-  如果使用 `start()` 方法，会创建新的线程，并在新线程中执行 `run()` 方法的代码。这样可以实现多线程的并发执行，充分利用多核处理器等硬件资源。 

 **总结：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。** 

