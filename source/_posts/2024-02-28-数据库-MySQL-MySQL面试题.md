---
title: MySQL 常见面试题总结
date: 2024-02-28 23:04:46
tags: 
  - MySQL
categories: 
  - Interview
password: zzy   
message: 仅管理员可见
---

#  数据库

## 关系型数据库

> 关系型数据库

- 基于关系模型组织数据的数据库，其以行和列的形式存储数据
- 关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。 

**实体关系模型**：

实体关系模型利用**实体-关系图**表示数据库的概念设计，有助于设计过程中的构思及沟通讨论 

**关系操作**：

- 数据查询：选择、投影、连接、并、交、差、除 
-  数据操作： 创建、删除、修改、查询

**完整性约束**：

- 实体完整性
- 参照完整性
- 用户定义完整性

## 模式结构

> 外模式

外模式用来描述用户看到的或使用的部分的数据的逻辑结构，用户根据外模式用户数据操作语句或者程序操作数据库中的数据。

> 模式

又称逻辑模式，是数据库中全部数据的逻辑结构和特征的描述。

> 内模式

内模式对应于物理机器的数据库，是三层模式中最底层的表示，描述数据在存储介质上的存储方式和物理结构

## 常见关系型数据库

* MySQL
* SQL Server
* Oracle
* SQLite

## MySQL

MySQL 是一款轻量级、高性能、可靠性强的数据库系统，广泛应用于 Web 应用程序开发和其他各种用途： 

- **关系型数据库：** 支持SQL语言，可以进行数据的管理和查询

- **存储引擎：** 支持多种存储引擎，如 InnoDB、MyISAM 等

- **事务支持：** 支持事务处理，允许以原子性、一致性、隔离性和持久性方式处理数据库操作

- **索引：** 允许创建索引以提高数据检索的性能
- **安全性：**提供访问控制和权限管理功能

- **备份和恢复：** 提供备份和恢复工具，可以定期备份数据以防止数据丢失，并在需要时进行恢复

- **复制和高可用性：**支持主从复制，允许在多个数据库服务器间同步数据，提高系统的可用性和容错性

#  MySQL 字段类型

> **数值类型**：

* 整型（`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT` 和 `BIGINT`）
* 浮点型（`FLOAT` 和 `DOUBLE`）
* 定点型（`DECIMAL`）

> **字符串类型**：

* `CHAR`、`VARCHAR`、`TINYTEXT`、`TEXT`、`MEDIUMTEXT`、 `LONGTEXT`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB` 等
* 最常用的是 `CHAR` 和 `VARCHAR`

> **日期时间类型**：

`YEAR`、`TIME`、`DATE`、`DATETIME` 和 `TIMESTAMP` 等

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-01.png)

## 整数类型的 UNSIGNED 属性

*  MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来 **表示不允许负值的无符号整数**
*  使用 UNSIGNED 属性**可以将正整数的上限提高 1 倍**，因为它不需要存储负数值 

TINYINT UNSIGNED 类型的取值范围是 `0 ~ 255`，而普通的 TINYINT 类型的值范围是 `-128 ~ 127`。INT UNSIGNED 类型的取值范围是 `0 ~ 4,294,967,295`，而普通的 INT 类型的值范围是 `-2,147,483,648 ~ 2,147,483,647` 

对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用 

## CHAR 和 VARCHAR 区别

> **CHAR：** 

-  CHAR 是**固定长度**的字符数据类型
-  当使用 CHAR 存储数据时，无论实际数据长度是多少，它会**占用固定的存储空间**。  如果指定CHAR(10)，不论实际数据是"abc"还是"abcdefghij"，都会占用10个字符的存储空间
-  CHAR 适用于**存储长度固定的字符**，如国家代码、固定长度的标识符等 
-  CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格

>  **VARCHAR** 

- VARCHAR 是**可变长度**的字符数据类型
- 当使用 VARCHAR 存储数据时，它只会**占用实际数据所需的存储空间**，加上一些额外的字节来存储长度信息。如果指定 VARCHAR(10)，实际数据是"abc"则只占用3个字符的存储空间
- VARCHAR 适用于**存储长度可变的字符**，如变长字符串、描述等

* VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理

## VARCHAR(100) 和 VARCHAR(10) 区别

* VARCHAR(100) 和 VARCHAR(10) 都是变长类型，表示能存储最多 100 个字符和 10 个字符
* 虽然 VARCHAR(100) 和 VARCHAR(10) 能存储的字符范围不同，**但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的** 

* VARCHAR(100) 会消耗更多内存，因为 VARCHAR 类型在内存中操作时，通常会分配固定大小内存块来保存值，即使用字符类型中定义的长度

## DECIMAL 和 FLOAT/DOUBLE 区别

 **精度和舍入：** 

- DECIMAL 是**定点数**，是一种精确的数值类型，它用于存储精确的小数值。DECIMAL的存储是固定的，它存储指定精度和小数位数的数字，**不会有任何近似误差**。 
- FLOAT/DOUBLE 是**浮点数**，是近似值类型，它们存储的是近似值，而不是精确值。在进行浮点数运算时，可能会发生**精度损失**，因为它们使用二进制表示法表示浮点数。 

 **存储空间：** 

- DECIMAL 需要足够的存储空间来保留指定的精度和小数位数。存储空间是**固定**的，与精度和小数位数有关 

- FLOAT和DOUBLE 存储空间是**可变**的，它们使用更复杂的表示方法，相对于DECIMAL来说可能需要更少的存储空间。

## 不推荐使用 TEXT 和 BLOB

**在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。**

> TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。 

| 类型       | 可存储大小           | 用途           |
| ---------- | -------------------- | -------------- |
| TINYTEXT   | 0-255 字节           | 一般文本字符串 |
| TEXT       | 0-65,535 字节        | 长文本字符串   |
| MEDIUMTEXT | 0-16,772,150 字节    | 较大文本数据   |
| LONGTEXT   | 0-4,294,967,295 字节 | 极大文本数据   |

> BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。 

| 类型       | 可存储大小 | 用途                     |
| ---------- | ---------- | ------------------------ |
| TINYBLOB   | 0-255 字节 | 短文本二进制字符串       |
| BLOB       | 0-65KB     | 二进制字符串             |
| MEDIUMBLOB | 0-16MB     | 二进制形式的长文本数据   |
| LONGBLOB   | 0-4GB      | 二进制形式的极大文本数据 |



> 数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如： 

- 不能有默认值
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。
- 检索效率较低
- 不能直接创建索引，需要指定前缀长度
- 可能会消耗大量的网络和 IO 带宽
- 可能导致表上的 DML 操作变慢

## DATETIME 和 TIMESTAMP 区别

 **表示范围：** 

-  DATETIME可以存储的日期时间范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'
-  TIMESTAMP可以存储的日期时间范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC。这是由于TIMESTAMP使用32位整数进行存储，表示自1970年以来的秒数，因此存在“Y2K38问题”
-  **Timestamp 表示的时间范围更小**

 **时区：** 

- DATETIME是不考虑时区的，它存储的日期时间是在指定的时区中的本地时间。
- TIMESTAMP存储的是自1970年以来的秒数（UTC），但在检索时会自动转换为连接会话的时区。因此，TIMESTAMP在存储时是相对于UTC的，但在检索时会根据时区进行调整。
- **DATETIME 类型没有时区信息，TIMESTAMP 和时区有关**

 **存储空间：** 

- DATETIME占用固定的8字节的存储空间。
- TIMESTAMP在MySQL 5.6.4版本之前占用4字节，之后占用7字节。这是因为在MySQL 5.6.4版本中引入了微秒的支持，允许存储更精确的时间。

**自动更新：**

- TIMESTAMP列可以设置为在INSERT或UPDATE时自动更新为当前的时间戳，可以通过设置DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP来实现。这在记录“最后修改时间”等方面很有用。
- DATETIME列不支持类似的自动更新功能，需要在应用层手动更新。

> 使用建议

- 如果需要存储绝对的日期和时间，而且不需要考虑时区，那么DATETIME可能更合适
- 如果需要记录事件发生的时间并考虑时区差异，那么TIMESTAMP可能更合适

>  DATETIME 与 TIMESTAMP  相互转化

**DATETIME 到 TIMESTAMP 的转换：** 

可以使用MySQL的内置函数`UNIX_TIMESTAMP()`将DATETIME类型的值转换为TIMESTAMP类型的值。 

```sql
SELECT UNIX_TIMESTAMP(your_datetime_column) AS your_timestamp_column FROM your_table;
```

这将返回一个UNIX时间戳，它是一个从1970年1月1日开始的秒数，代表了给定的DATETIME值。 

**TIMESTAMP 到 DATETIME 的转换：**

可以使用`FROM_UNIXTIME()`函数将 TIMESTAMP 类型的值转换为 DATETIME 类型的值。 

```sql
SELECT FROM_UNIXTIME(your_timestamp_column) AS your_datetime_column FROM your_table;
```

这将返回一个DATETIME类型的值，表示从1970年1月1日起的给定UNIX时间戳。 



## NULL 和 '' 区别

>  **NULL：** 

-  `NULL` 表示缺失或未知，**用于表示缺失数据，而不是表示空值**
-  判断 `NULL`值**必须使用** `IS NULL` 或 `IS NOT NULL`，而不能使用`=、!=、 <、>` 之类的比较运算符。而`''`是可以使用这些比较运算符的。  
-  当列的值未知、不适用或没有被填充时，该列可以存储`NULL`
-  如果列定义为允许`NULL`，那么该列可以包含`NULL`值
-  两个 `NULL`不一定相等。  例如，`SELECT NULL=NULL`的结果为 false，但是在我们使用`DISTINCT`,`GROUP BY`,`ORDER BY`时,`NULL`又被认为是相等的。
-  `NULL` **会影响聚合函数的结果**
   - `SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值
   - `COUNT` 的处理方式取决于参数的类型
     -   如果参数是 `(COUNT(*)`，则会统计所有的记录数，包括 `NULL` 值
     -   如果参数是字段名`COUNT(列名)`，则会忽略 `NULL` 值，只统计非空值的个数

>  **空字符串 `''`：** 

- 空字符串表示长度为 **零** 的字符串。它是一个有效的字符串值，只是其中没有任何字符
- 当列定义为不允许`NULL`且数据类型是字符串时，该列不能包含`NULL`值，但可以包含空字符串

- `''` 的长度是 0 且不占用空间，而`NULL` 需要占用空间

> **为什么 MySQL 不建议使用 `NULL` 作为列默认值？**

- **不确定性**：`NULL` 表示缺少值或未知值，它与空字符串 `''` 是不同的。在使用 `NULL`  作为列默认值时，可能会导致查询结果不确定，因为 `NULL` 的含义是不确定的，不仅给开发人员带来困惑，并且可能导致错误的查询结果
- **数据一致性**：使用 `NULL` 作为列默认值可能会导致数据一致性问题。如果列允许 `NULL` 值，那么在插入数据时，没有明确指定该列值，MySQL 会将 `NULL` 作为默认值插入，可能会导致数据不一致，因为不同的行可能具有不同的 `NULL` 值。

- **索引效率**：使用 `NULL` 作为列默认值可能会降低数据库的性能。当一个列允许 `NULL` 值时，MySQL 在创建索引时需要额外的空间来存储 `NULL` 值，会增加索引的大小，并且可能导致查询的效率降低。

## Boolean 类型如何表示

在 MySQL 中，Boolean 类型通常用 `TINYINT(1)` 来表示，因为 MySQL 没有直接的 `BOOLEAN` 数据类型，但`TINYINT(1)` 是一个常见的替代方案，被用作布尔值的容器 

* MySQL 中没有专门的布尔类型，而是用 `TINYINT(1)` 类型来表示布尔值
* `TINYINT(1)` 类型可以存储 `0` 或 `1`，分别对应 `false` 或 `true`



#  MySQL 存储引擎

## MySQL 支持的存储引擎和默认使用的存储引擎

> 存储引擎

```sql
-- 查看 MySQL 支持的所有存储引擎
SHOW ENGINES
```

* MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎，不支持事务
* MySQL 5.5.5 版本之后，**InnoDB** 是 MySQL 的默认存储引擎，支持事务

> MySQL 版本

```sql
mysql> SELECT VERSION();
+-----------+
| VERSION() |
+-----------+
| 8.0.27    |
+-----------+
1 row in set (0.00 sec)
```

> 查看 MySQL 当前默认的存储引擎

```sql
mysql> SHOW VARIABLES  LIKE '%storage_engine%';
+---------------------------------+-----------+
| Variable_name                   | Value     |
+---------------------------------+-----------+
| default_storage_engine          | InnoDB    |
| default_tmp_storage_engine      | InnoDB    |
| disabled_storage_engines        |           |
| internal_tmp_mem_storage_engine | TempTable |
+---------------------------------+-----------+
4 rows in set (0.00 sec)
```

## MySQL 存储引擎架构

* MySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎，甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要
* **存储引擎是基于表的，而不是数据库** 

> 常见存储引擎

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-02.png)

> 更多请参考

[MySQL 存储引擎](https://cyanzzy.github.io/2023/08/12/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87-5-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/)

## MyISAM 和 InnoDB 区别

* MySQL 5.5 前，MyISAM 引擎是 MySQL 的默认存储引擎，但 MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。 

* MySQL 5.5 后，InnoDB 是 MySQL 的默认存储引擎。 

**是否支持行级锁** 

* MyISAM 只有表级锁（table-level locking）
* InnoDB 支持行级锁（row-level locking）和表级锁，**默认为行级锁**。 

**是否支持事务** 

* MyISAM 不支持事务

* InnoDB 支持事务，实现了 SQL 标准定义四个隔离级别，具有提交（commit）和回滚（rollback）事务的能力。 

* InnoDB 默认使用的 `REPEATABLE-READ`（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。 

**是否支持外键** 

- MyISAM 不支持外键，而 InnoDB 支持外键

- 外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。通常情况下，不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！ 

**是否支持数据库异常崩溃后的安全恢复** 

* MyISAM 不支持，而 InnoDB 支持。 

* 使用 InnoDB 的数据库在异常崩溃后，数据库重新启动时会保证数据库恢复到崩溃前的状态，此恢复过程依赖于 `redo log` 。 

**是否支持 MVCC** 

- MyISAM 不支持 MVCC
- InnoDB 支持 MVCC

**索引实现不一样** 

* 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。 

* InnoDB 引擎中，其数据文件本身就是索引文件
* MyISAM 索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。 

**性能有差别** 

* InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，  InnoDB 的读写能力呈线性增长
* MyISAM 因为读写不能并发，它的处理能力跟核数没关系 

> **面试**：

- MyISAM 不支持行级别的锁粒度，只支持表级别的锁粒度；InnoDB 支持行级别的锁粒度 
- MyISAM 不提供事务支持；InnoDB 提供事务支持，并实现 SQL 标准定义了四个隔离级别 
- MyISAM 不支持外键；InnoDB 支持外键
- MyISAM 不支持 MVCC；InnoDB  支持MVCC
- 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样 
- MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持安全恢复
- InnoDB 的性能比 MyISAM 更强大

## MyISAM 和 InnoDB 如何选择

**事务支持：**

- MyISAM 不支持事务
- InnoDB 支持事务
- 如果需要事务支持（例如，确保一组操作要么全部成功要么全部失败），则应选择 InnoDB

**锁的类型：**

- MyISAM 支持表级锁，在执行写操作时，整个表被锁定，可能导致并发性能较差
- InnoDB 支持行级锁，只锁定被修改的行，提高并发性能
- 如果需要更好的并发性，特别是在高并发环境下，选择 InnoDB 更合适

**崩溃恢复：**

- InnoDB 支持崩溃恢复，可以在数据库崩溃后进行自动恢复
- MyISAM 对于崩溃恢复的支持相对较差
- 如果需要保证数据完整性和可靠性，选择 InnoDB。

**外键约束：**

- MyISAM 不支持外键约束
- InnoDB 支持外键约束
- 如果数据库设计需要使用外键来确保数据一致性，选择 InnoDB。

**全文索引：**

- MyISAM 支持全文索引
- InnoDB 在某些版本中也开始支持全文索引
- 如果需要全文搜索功能，可以考虑 MyISAM，但也可以查看 InnoDB 的全文索引功能。

**性能需求：**

- 在一些特定的读多写少的场景下，MyISAM 可能表现得更好
- 但在读写混合或写多的情况下，InnoDB 通常更优秀。

**空间和性能考虑：**

- MyISAM 对于只读数据的查询和空间利用率可能更好
- InnoDB 由于它支持事务和崩溃恢复机制，在存储大量数据时可能占用更多的磁盘空间

> 总结

- 如果需要事务支持、更好的并发性和数据完整性，那么选择 InnoDB 
- 如果读为主，对事务支持不敏感，并且更注重性能，那么 MyISAM 可能更合适

#  MySQL 查询缓存（MySQL 8.0 版本后移除）

## 查询缓存

MySQL 查询缓存是一种机制，它允许 MySQL 在执行查询时缓存查询结果，以便对相同的查询进行重用，从而提高性能。

## 弃用查询缓存

MySQL 弃用查询缓存的主要原因是无法与多核计算机上的高吞吐量工作负载进行扩展，**查询缓存在处理高并发的情况下会导致性能下降**，因为每次对表进行更新操作时，缓存中的所有相关查询结果都会被清除，这会导致频繁的缓存失效和重新加载。此外，**查询缓存还存在内存管理和锁定机制的问题**，这些问题会进一步影响性能。

MySQL 8.0 版本中删除了查询缓存，主要是为提高整体性能和可扩展性。通过删除查询缓存，MySQL 可以更好地利用多核计算机的处理能力，并更好地处理高并发的工作负载。此外，MySQL 还引入了其他性能优化措施，如更好的索引算法和查询优化器，以提高查询性能。

MySQL 弃用查询缓存的原因是：

- 无法与多核计算机上的高吞吐量工作负载进行扩展 
- 缓存失效和重新加载导致性能下降 
- 存在内存管理和锁定机制的问题 

 **不建议使用的原因：**

查询缓存的性能问题主要源于缓存失效的代价，以及在高并发环境中可能导致的锁竞争

**替代方案：**

在不使用查询缓存的情况下，可以通过使用更先进的缓存策略、优化查询、使用合适的索引等方法来提高数据库性能。缓存策略可以包括在应用层使用缓存（如 Memcached 或 Redis）或数据库层面的缓存（如使用 InnoDB 的缓冲池）。

## 启用和禁用查询缓存

 查询缓存默认是启用的，可以通过在 MySQL 配置文件中设置 `query_cache_type` 参数来禁用或启用查询缓存。将该参数设置为 `OFF` 可以禁用查询缓存。 

开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。缓存虽然能够提升数据库的查询性能，但是缓存同时也带来额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁

因此开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。 如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适

此外，还可以通过 `sql_cache` 和 `sql_no_cache` 来控制某个查询语句是否需要缓存： 

```sql
SELECT sql_no_cache COUNT(*) FROM usr;
```

> **启用查询缓存**

 `my.cnf` 文件：

```properties
query_cache_type = ON
```

> **禁用查询缓存**

 `my.cnf` 文件：

```properties
query_cache_type = OFF
```

**验证查询缓存状态**

```sql
SHOW VARIABLES LIKE 'query_cache_type';
```

## 查询缓存的工作原理 

1. 当查询请求到来时，MySQL 首先会在缓存中查找该条 SQL 是否已经被缓存过
2. 如果已经被缓存，则直接从缓存中返回查询结果
3. 否则，才会真正去数据库中进行查询 

然而，MySQL查询缓存在实际应用中存在一些限制和问题：

- 查询缓存只对完全匹配的SQL语句进行缓存，如果SQL语句中有任何变化（如参数值的变化），就无法使用缓存
- 当对数据库进行更新操作（如插入、更新、删除）时，MySQL会自动将与该表相关的所有缓存都标记为无效，这样会导致大量的缓存失效，降低了缓存的效率
- 查询缓存的大小是有限的，如果缓存空间不够，就会导致一些查询结果无法被缓存 

为了解决这些问题，需要清空 MySQL 查询缓存：

```sql
-- 这个命令会立即清空查询缓存，并且使得所有的查询都需要重新进行查询和缓存
FLUSH QUERY CACHE;

```

## 缓存的粒度

 MySQL 查询缓存的粒度是整个查询。如果两个查询语句在文本上完全相同，它们会共享相同的缓存结果，即使它们查询的是不同的数据表。 

## 缓存失效 

1. 缓存建立后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效
2. 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存
3. 缓存仅适用于一些特定类型的查询语句，例如 `SELECT`。包含诸如 `UPDATE`、`INSERT`、`DELETE` 或包含子查询的查询语句通常不会被缓存。 
4. 如果缓存空间被用尽，MySQL 将根据一定的策略来选择缓存中的哪些查询结果将被删除，以为新的查询结果腾出空间。这可能导致之前缓存的查询结果失效。

#  MySQL 事务

## 数据库事务

> **事务是逻辑上的一组操作，要么都执行，要么都不执行。** 

假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。 

1. 将小明的余额减少 1000 元
2. 将小红的余额增加 1000 元。

 事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败，这样就不会出现小明余额减少而小红的余额却并没有增加的情况。 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-03.png)

> 数据库事务

 数据库事务可以保证多个对数据库的操作构成一个逻辑上的整体：**要么全部执行成功，要么全部不执行** 。 

```mysql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
# 提交事务
COMMIT;
```

## 事务的 **ACID** 特性

> 关系型数据库（例如：`MySQL`、`SQL Server`、`Oracle` 等）事务都有 **ACID** 特性： 

| ACID 特性                   | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| **原子性**（`Atomicity`）   | 一个事务中的所有操作，要么全部完成，要么全部不完成           |
| **一致性**（`Consistency`） | 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。     |
| **隔离性**（`Isolation`）   | 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 |
| **持久性**（`Durability`）  | 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 |

 **只有保证事务的持久性、原子性、隔离性之后，一致性才能得到保障。** 

## 事务并发问题

> **脏读（Dirty read）：事务 T1 读取事务 T2 尚未提交的数据**

对于两个事务 T1、T2，T1 读取了已经被 T2 更新但还没有被提交的字段。之后， 若 T2 回滚，T1 读取的内容就是临时且无效的

**小栗子：** 事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到  A = 19，事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-04.png)

> **脏写（Dirty write）：事务 T1 修改事务 T2 修改过且尚未提交的数据**

对于两个事务 T1、T2，T1 修改了另一个未提交的事务 T2 修改过的数据（丢失修改）

 **小栗子：**事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-05.png)

> **不可重复读（Unrepeatable read）：事务 T1 读取某记录后，事务 T2 对该记录修改并提交，T1 再次读取该记录出现不同结果**

对于两个事务 T1、T2，T1 读取了一个字段，然后 T2 更新了该字段。之后 T1 再次读取同一个字段，值就不同了

**小栗子**：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-06.png)

> **幻读（Phantom read）：事务 T1 读取若干记录行期间，事务 T2 插入新的记录。之后，T1 再次读取相同范围的数据会多出几行**

对于两个事务 T1、T2，T1从一个表中读取了一个字段，然后 T2 在该表中插入了一些新的行。之后，如果 T1 再次读取同一个表，就会多出几行

**小栗子：**事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。 

![](https://cyan-images.oss-cn-shanghai.aliyuncs.com/images/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-07.png)

## 不可重复读和幻读区别

**不可重复读 (Non-Repeatable Read)：**

- 不可重复读指的是在同一事务中，两次读取相同的数据，但得到的结果却不一致。这可能是由于在事务执行期间，另一个事务对相同的数据进行了更新操作，导致两次读取的结果不同。
- 不可重复读主要涉及到数据的**更新操作**。

**幻读 (Phantom Read)：**

- 幻读则强调的是在同一事务中，两次查询同一个范围的数据，但第二次查询却发现了新插入的数据，从而导致结果集不一致。幻读通常与插入操作有关。
- 幻读主要涉及到数据的插入或删除操作。



## 并发事务的控制方式

> MySQL 中并发事务的控制方式无非就两种：**锁** 和 **MVCC**。

* 锁可以看作是悲观控制的模式
* 多版本并发控制 （MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。 

> 锁方式

MySQL 中主要是通过 **读写锁** 来实现并发控制， **锁** 控制方式下会通过锁来显示控制共享资源

- **共享锁（S 锁）**：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）

- **排他锁（X 锁）**：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）

**读写锁可以做到读读并行，但是无法做到写读、写写并行。**另外，根据根据锁粒度的不同，又被分为 **表级锁和行级锁** 。  

InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。  不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。 

> MVCC 方式

**MVCC** 是多版本并发控制方法，即**对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本**。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。 

MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。 

- undo log：undo log 用于记录某行数据的多个版本的数据。
- read view 和 隐藏字段：用来判断当前版本数据的可见性。



## SQL 标准定义的事务隔离级别

> 事务的隔离级别

数据库管理系统中用于控制并发访问的一种机制，定义了在多个事务同时执行时，一个事务的操作是否会受到其他事务的影响。 

> SQL 标准定义的四个隔离级别： 

| 隔离级别                         | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| **READ-UNCOMMITTED(读取未提交)** | 最低的隔离级别，允许事务读取其他事务未提交的变更，会出现脏读、不可重复读、幻读的问题 |
| **READ-COMMITTED(读取已提交)**   | 只允许事务读取已经被其他事务提交的变更，可以避免脏读，但存在不可重复读、幻读的问题 |
| **REPEATABLE-READ(可重复读)**    | 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行**更新**，避免了脏读和不可重复读，但存在幻读问题 |
| **SERIALIZABLE(可串行化)**       | 最高的隔离级别，确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除的操作，解决所有的并发问题，但是性能低下 |

| 隔离级别        | 脏读可能性 | 不可重复读可能性 | 幻读可能性 |
| --------------- | ---------- | ---------------- | ---------- |
| READ UNCOMMITED | Y          | Y                | Y          |
| READ COMMITTED  | N          | Y                | Y          |
| REPETABLE READ  | N          | N                | Y          |
| SERIALIZABLE    | N          | N                | N          |

## MySQL 的隔离级别实现方式

* MySQL 的隔离级别基于锁和 MVCC 机制共同实现的 

* `SERIALIZABLE` 隔离级别是基于**锁**实现的
* `READ-COMMITTED` 和 `REPEATABLE-READ` 隔离级别是基于 **MVCC** 实现的
* 不过，SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。 

## MySQL 的默认隔离级别

* MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**
* 可以通过`SELECT @@tx_isolation;`命令来查看
* MySQL 8.0 该命令改为`SELECT @@transaction_isolation;` 

```sql
mysql> SELECT @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```

#  MySQL 锁

 锁是一种常见的并发事务的控制方式

## 表级锁和行级锁

*  MyISAM 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。  
*  InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。 
*  行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高 

> 表级锁

-  **锁范围：**  表级锁是对整个表的锁定，当一个事务获取了表级锁后，其他事务无法同时获得相同表的锁。在表级锁定期间，其他事务无法对该表进行任何操作
-  **优点**：开销小，加锁快，不会出现死锁。
-  **缺点**：锁定粒度大，发生锁冲突的概率最高，并发度最低

-  **适用场景：**  表级锁通常用于涉及大量数据修改或涉及整个表的操作。在高并发环境下，使用表级锁可能导致性能问题，因为锁的粒度较大。 

```sql
-- 获取表级锁
LOCK TABLES table_name [AS alias] {READ | WRITE};

-- 释放表级锁
UNLOCK TABLES;
```

> 行级锁

-  **锁范围：**行级锁是对表中的某一行或某些行进行锁定，当一个事务获取了某行的锁后，其他事务仍然可以同时获得表中其他行的锁，这允许更多的并发访问。 
-  **优点**：锁定粒度小，生锁冲突的概率较低，并发度较高。
-  **缺点**：开销较大，加锁慢，可能会出现死锁。
-  **适用场景：**  行级锁通常用于涉及对表中的特定行进行读写操作的场景。在高并发环境下，使用行级锁可以提高并发性，但也可能引入更多的锁管理开销。 

```sql
-- 获取行级锁
SELECT * FROM table_name WHERE condition FOR UPDATE;
或
SELECT * FROM table_name WHERE condition LOCK IN SHARE MODE;

-- 行级锁的释放是隐式的，当事务提交或回滚时会释放行级锁。
```

>  **表级锁和行级锁对比**： 

**锁粒度：** 

- 表级锁的粒度更大，表级锁并发度低，可能导致并发性能问题，因为一次只有一个事务能够访问整个表。适用于一些大型批量操作或需要对整个表进行修改的场景。
- 行级锁的粒度更小，行级锁并发度高，允许更多的并发，因为不同的事务可以同时锁定表中不同的行。适用于需要频繁读写表中不同行的场景。

 **性能开销：**

  - 表级锁可能会引入更大的性能开销，因为锁定整个表可能阻塞其他事务的访问 
  - 行级锁在并发性能上更有优势，但可能引入更多的锁管理开销。

**死锁风险：**

  - 表级锁的死锁风险较低，因为一个事务只需等待对整个表的锁的释放 
  - 行级锁的死锁风险较高，因为多个事务可能同时等待对不同行的锁的释放，可能导致死锁 

  **存储引擎：**

* 表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁 

* 行级锁和存储引擎有关，是在存储引擎层面实现的 

> 使用行级锁的注意事项

* InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁
* 当执行 `UPDATE` 或 `DELETE` 语句时，如果 `WHERE` 条件中的字段命中索引，InnoDB 会对相关的记录进行行级锁定。这样可以提高并发写入操作的性能，因为行级锁的粒度更小，只锁定相关的记录
* 当执行 `UPDATE`、`DELETE` 语句时，如果 `WHERE`条件中字段的未命中索引或者索引失效，InnoDB 会全表扫描并对表中的所有记录进行表级锁定。这种情况下，对于并发写入操作来说，性能可能会受到影响 

## InnoDB 行锁分类

InnoDB 行锁基于对索引数据页上的记录加锁实现

> 在 MySQL InnoDB 存储引擎中，存在三种重要的行级锁定方式，这些锁定方式用于处理不同的并发情况，以确保事务的一致性和隔离性。 

 **Record Lock（记录锁定）：** 

- **概念**：Record Lock  锁定某一行的索引记录，阻止其他事务对同一行的索引记录进行修改。 
- **使用场景：** 当一个事务对某一行进行修改时，它会请求该行的 Record Lock，防止其他事务同时修改同一行的数据。 

 **Gap Lock（间隙锁定）：** 

- **概念：** Gap Lock **锁定范围而不是具体的行**（**不包含记录**），锁定一个范围内的记录间隙，以确保其他事务不能在这个范围内插入新的记录，从而防止其他事务在查询时产生幻读现象
- **使用场景：** 当事务在某个范围内插入新行时，会请求该范围的 Gap Lock，防止其他事务在同一范围内插入新行，确保范围内的行不会被其他事务插入。 

 **Next-Key Lock（临键锁定）：** 

-  **概念：** `Next-Key Lock = Record Lock + Gap Lock `， Next-Key Lock是对记录和记录间隙（gap）的组合锁，它同时锁定某一行的索引记录和该行之前的间隙（包含记录本身），确保事务在读取或修改一行的同时，对于范围内的间隙也进行了锁定。  
-  **使用场景：** Next-Key Lock 通常用于**处理范围查询**，确保范围内的数据不被其他事务修改或插入。 主要目的是为**解决幻读问题**。  记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。 

> 注意

* 在 InnoDB 默认的隔离级别 `REPEATABLE-READ` 下，行锁默认使用的是 `Next-Key Lock` 
* 但如果操作的索引是唯一索引或主键，InnoDB 会对 `Next-Key Lock` 进行优化，将其降级为 `Record Lock`，即仅锁住索引本身，而不是范围。

> 更多知识点请参考

- 一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：[MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021](https://segmentfault.com/a/1190000040129107) 

- [MySQL 锁](https://cyanzzy.github.io/2023/08/26/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87-15-%E9%94%81)

## 共享锁和排他锁

> 不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类： 

 **共享锁（Shared Locks）：** 

- 共享锁用于读操作，允许多个事务同时持有共享锁。当一个事务持有共享锁时，其他事务也可以获取共享锁，但是不允许获取排他锁。多个事务可以同时读取相同的资源，因为共享锁不会阻塞其他事务的共享锁。 
- **关键字：** `SELECT ... FOR SHARE` 或 `SELECT ... LOCK IN SHARE MODE` 

由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁。

```sql
-- 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
SELECT ... LOCK IN SHARE MODE;
-- 共享锁 可以在 MySQL 8.0 中使用
SELECT ... FOR SHARE;
```

 **排他锁（Exclusive Locks）：** 

-  排他锁用于写操作，一次只允许一个事务持有排他锁。当一个事务持有排他锁时，其他事务无法同时获取任何类型的锁。排他锁用于独占性的写入，以防止其他事务对同一资源进行读取或写入。 

-  **关键字：** `SELECT ... FOR UPDATE` 

由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加排他锁。

```sql
-- 排他锁
SELECT ... FOR UPDATE;
```

## 意向锁（表锁）

MySQL 中的意向锁（Intention Locks）是一种**用于协调事务之间的锁定意图的机制**。意向锁是为协调不同层次的锁定（行级、页级、表级锁）而引入的， 用于表明事务打算在某一级别上锁定资源 

 意向锁有两种类型：意向共享锁（Intention Shared Locks）和意向排他锁（Intention Exclusive Locks）。这两种意向锁并不是直接用于行或页的锁定，而是**用于指示一个事务打算在某个层次上获取共享锁或排他锁**。 

比如， 如果需要用到表锁，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们**使用意向锁快速判断是否可以对某个表使用表锁。** 

> **意向共享锁（Intention Shared Lock，IS 锁）**：

- 表示一个事务打算在某个层次上获取共享锁。当事务打算在某个层次上获取共享锁时，需要先获取意向共享锁。这有助于其他事务了解当前事务的意图，以便更好地协调锁的分配。 
- 在 InnoDB 中，为获取表级共享锁，事务首先会尝试获取意向共享锁。
- **事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁** 

事务有意向对表中的某些行加共享锁 S 锁：

```sql
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
SELECT column FROM table ... LOCK IN SHARE MODE;
```

> **意向排他锁（Intention Exclusive Lock，IX 锁）**：

- 表示一个事务打算在某个层次上获取排他锁。当事务打算在某个层次上获取排他锁时，需要先获取意向排他锁。
- 在 InnoDB 中，为获取表级排他锁，事务首先会尝试获取意向排他锁。

- **事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁**

 事务有意向对表中的某些行加排他锁`X锁` ：

```sql
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
SELECT column FROM table ... FOR UPDATE;
```

> 问题背景

 当 `事务A` 想获取某个表的表锁时需要对该表下的每一行记录进行遍历，查看是否有其他事务进行锁的获取，如果存在排它锁，则需要等待其他事务释放所有锁才能后的表锁。其中的遍历成本大，需要一个更好的方法避免这种问题。 

> 解决方案

当`事务B`对表中的某个记录加行锁时，首先对粒度更粗的表加意向锁，其他事务获取表锁时，看表上是否存在意向锁，如果存在则直接等待`事务B`释放锁，减少了锁查询的消耗。

- 有两个事务 `T1` 和 `T2`，其中 `T2` 试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么 `T2` 就需要去检查各个页或行是否存在锁
- 如果存在意向锁，那么此时就会受到由 `T1` 控制的表级别意向锁的阻塞。`T2`  在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁，就是给更大一级别的空间示意里面是否已经上过锁。 

在数据表的场景中，如果给某行数据加上排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经上了排它锁，当其他人想要获取数据表排它锁时，只需了解是否有人已经获取这个数据表的意向排他锁即可。

- 如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁
- 如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁

此时意向锁会告诉其他事务已经有人锁定了表中的某些记录 

> 意向锁的并发性

 意向锁不会与行级的共享 / 排他锁互斥，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性，InnoDB 支持`多粒度锁`，特定场景下行级锁可以与表级锁共存

 **意向锁之间互不排斥** ：

|       | IS 锁 | IX 锁 |
| ----- | ----- | ----- |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

 **意向锁和共享锁和排它锁互斥**：

- 意向锁之间互不排斥，但除了`IS`与`S`兼容外， `意向锁`会与`共享锁 / 排他锁`互斥

- `IX`，`IS`是表级锁，不会和行级的`X`，`S`锁发生冲突
- 这里指的是表级别的共享锁和排他锁，只会和表级的`X`，`S`发生冲突 

|      | IS 锁 | IX 锁 |
| ---- | ----- | ----- |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |

## 当前读和快照读区别

在 MySQL 中，有两种主要的事务隔离级别，它们涉及到不同的读取方式：当前读（Read Committed）和快照读（Repeatable Read）。这两种读取方式主要影响了事务在读取数据时的一致性和隔离性。 

> **当前读** （一致性锁定读）

- 当前读是一种较低的隔离级别。
- 在当前读下，事务读取的是数据表中**已经提交的最新版本**，但是在同一个事务内的不同语句之间，数据可能会发生变化。 
- 当前读使用**瞬时快照读**，即在事务开始时创建一个快照，之后的读操作都基于这个快照，但在同一事务内不同的查询可能会看到不一样的数据。 
- **关键字：** `SELECT ... FOR UPDATE` 和 `SELECT ... FOR SHARE` 

 当前读就是给行记录加 X 锁或 S 锁：

```sql
-- 对读的记录加一个 X 锁
SELECT...FOR UPDATE
-- 对读的记录加一个 S 锁
SELECT...LOCK IN SHARE MODE
-- 对读的记录加一个 S 锁
SELECT...FOR SHARE
-- 对修改的记录加一个 X 锁
INSERT...
UPDATE...
DELETE...
```


> **快照读**（一致性非锁定读）

- 快照读是一种较高的隔离级别。
- 在快照读下，事务读取的是事务开始时的一个快照，因此在同一个事务内，相同的查询会看到一致的数据。其他事务的更新对当前事务不可见。 
- 快照读会在事务开始时创建**一致性视图**，之后的读操作都基于这个一致性视图。 
- **关键字：** 默认隔离级别是 `REPEATABLE READ` 
- **适用场景：** 快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。 

快照读就是单纯的 `SELECT` 语句，但不包括下面这两类 `SELECT` 语句：

```sql
SELECT ... FOR UPDATE
-- 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
SELECT ... LOCK IN SHARE MODE;
-- 共享锁 可以在 MySQL 8.0 中使用
SELECT ... FOR SHARE;
```

**快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。**快照读的情况下，如果读取的记录正在执行 `UPDATE/DELETE` 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。 

 只有在事务隔离级别 `RC`（读已提交）和 `RR`（可重复读）下，InnoDB 才会使用一致性非锁定读（快照读）： 

- 在 **读已提交** 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。
- 在 **可重复读** 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。

## 自增锁


在 MySQL 中，当使用自增（auto-increment）列插入新数据时，InnoDB 存储引擎使用了一种称为 `auto-increment锁` 的机制，目的是为保证并发事务中的自增列的唯一性，防止多个事务同时插入记录时产生相同的自增值。

> 自增锁工作原理

1. 当一个事务插入一条新记录时，InnoDB 会为这个插入操作分配一个全局的 `auto-increment` 锁。
2. 在该事务插入完成前，其他事务要插入具有相同 `auto-increment` 值的记录会被阻塞，直到插入操作完成释放锁。
3. 一旦事务完成插入，锁就会被释放，其他事务就可以插入下一个 `auto-increment` 值的记录。

这确保了在并发环境中，不同事务插入的记录都有唯一的 auto-increment 值。

需要注意的是，`auto-increment` 锁的粒度是全局的，因此在高并发的情况下，可能会出现一些性能瓶颈。一种方式是通过调整InnoDB的`auto-increment`锁的争用（Contention）参数来尝试优化，但这需要根据具体的业务需求和系统性能进行调整。

- MySQL 的自增锁机制是为确保在并发环境下生成唯一的自增值，以防止冲突和数据不一致性。
- 自增锁是当向使用含有 `AUTO_INCREMENT` 列的表中插入数据时需要获取的一种特殊的**表级锁**，在执行插入语句时就在表级别加自增锁，然后为每条待插入记录的 `AUTO_INCREMENT` 修饰的列分配递增的值，在该语句执行结束后，再把自增锁释放掉。

> 锁定机制

事务在持有自增锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。当向一个有 `AUTO_INCREMENT` 关键字的主键插入值时，每条语句都要对这 `表锁` 进行竞争，因此 Innodb 通过`innodb_autoinc_lock_mode` 不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能：

`innodb_autoinc_lock_mode = 0`： **传统锁定模式**

此锁定模式下所有类型的 insert 语句都会获得特殊的表级自增锁，用于插入具有 `AUTO_INCREMENT` 列的表，当在同一时间多个事务中执行 insert 时，对于自增锁的竞争会限制并发 能力

`innodb_autoinc_lock_mode = 1`： **连续锁定模式** （8.0 前默认）

此锁定模式下 `bulk inserts` 使用 `AUTO-INC` 表级锁并保持到语句结束，适用于所有 `INSERT ... SELECT`，`REPLACE ... SELECT` 和`LOAD DATA`语句。同一时刻只有一个语句可以持有`AUTO-INC`锁

`innodb_autoinc_lock_mode = 2`： **交错锁定模式** （8.0 后默认）

此锁定模式下自动递增值保证在所有并发执行的所有类型的 insert 语句中是唯一且单调递增的，由于多个语句可以同时生成数字，为任何给定语句插入的行生成的值可能不是连续的

 交错模式下，所有的插入语句，包括：`INSERT`、`REPLACE`、`INSERT…SELECT`、  `REPLACE…SELECT`、`LOAD DATA`等都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。 

如果 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。 这是因为并发情况下插入语句的执行顺序就无法得到保障。  

 如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句 

> 文章推荐

[为什么 MySQL 的自增主键不单调也不连续](https://draveness.me/whys-the-design-mysql-auto-increment/) 

